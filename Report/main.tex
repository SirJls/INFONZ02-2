%------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%------------------------------------------------------------------------------

\documentclass[twoside,twocolumn]{article}

\usepackage[dutch]{babel} % Language hyphenation and typographical rules

\usepackage[
  backend=biber,
    style=numeric-comp,
  ]{biblatex}
\addbibresource{main.bib}

\usepackage{csquotes}

\usepackage{listings}
\lstdefinelanguage{Lambda}{%
  morekeywords={%
    if,then,else,fix % keywords go here
  },%
  morekeywords={[2]int,string},   % types go here
  otherkeywords={:}, % operators go here
  literate={% replace strings with symbols
    {->}{{$\to$}}{2}
    {lambda}{{$\lambda$}}{1}
  },
  basicstyle={\sffamily},
  keywordstyle={\bfseries},
  keywordstyle={[2]\itshape}, % style for types
  keepspaces,
  mathescape % optional
}[keywords,comments,strings]%
\lstdefinestyle{CStyle}{language=C,frame=t,basicstyle=\scriptsize}
\lstdefinestyle{HsStyle}{language=Haskell,frame=b,basicstyle=\scriptsize}
\lstdefinestyle{LambdaStyle}{
  language=Lambda,
  frame=bt,
  basicstyle=\scriptsize,
  numberstyle=\tiny,
  numbersep=0pt,
}

\lstset{
  language=Lambda,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  postbreak=\mbox{\textcolor{RoyalRed}{$\drsh$}\space},
  numbers
}


\usepackage{blindtext} % Package to generate dummy text throughout this template

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{amsmath}
\usepackage{mathabx}


\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{subfig}

\usepackage{algorithmicx} % We need to write some pseudocode
\usepackage{algorithm, algpseudocode} % We need floating algorithms

\algdef{SE}[VARIABLES]{Variables}{EndVariables}
   {\algorithmicvariables}
   {\algorithmicend\ \algorithmicvariables}
\algnewcommand{\algorithmicvariables}{\textbf{Shared Variable}}

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{multicol} % We need multicolumn support for appendix

\usepackage{graphicx} % Graphics

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{Het functionele paradigma is de toekomst} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

% \addto\captionsdutch{\renewcommand{\appendixname}{Bijlage}} % changes 'BÃ¿lage' to 'Bijlage' for the bookmarks

\usepackage{xcolor}
\definecolor{RoyalBlue}{RGB}{0,35,102}
\definecolor{RoyalRed}{RGB}{157,16,45}
\definecolor{Orange}{RGB}{255,127,0}

\usepackage[
  pdfusetitle
    ,colorlinks=true
    ,allcolors=RoyalBlue
    ,pdfborder={0 0 0}
    ,unicode=true
  ]{hyperref}

\usepackage[toc,title]{appendix}
\usepackage[dutch]{cleveref}

%------------------------------------------------------------------------------
%	FIGURES
%------------------------------------------------------------------------------
\newcommand{\igopt}[2]{\includegraphics[#1]{#2}} %%! options, filename

\newcommand{\ig}[2]{\igopt{width=#1\columnwidth}{#2}} %%! width in units of textwidth, filename

\newcommand{\figopt}[4]{ %%! width, filename, caption, placement (h, t, ht)
  \begin{figure}[#4]
    \centering
        \ig{#1}{#2}
        \caption{#3}
        \label{fig:#2}
  \end{figure}
}

\newcommand{\fig}[3]{ %%! width, filename, caption
  \figopt{#1}{#2}{#3}{ht}
}

\newcommand{\doublefigopt}[8]{ %%! w1, f1, c1, w2, f2, c2, main caption, placement
  \begin{figure}[#8]
    \centering
        \subfloat[#3]{
          \ig{#1}{#2}
            \label{fig:#2}
          }
        \subfloat[#6]{
          \ig{#4}{#5}
            \label{fig:#5}
          }
        \caption{#7}
        \label{fig:#2_#5}
  \end{figure}
}

\newcommand{\doublefig}[7]{\doublefigopt{#1}{#2}{#3}{#4}{#5}{#6}{#7}{ht}} %%! w1, f1, c1, w2, f2, c2, main caption

%------------------------------------------------------------------------------
%	APPEDIX ENTRIES
%------------------------------------------------------------------------------

% Headings within sections.
% Parameter 1: Section name.
\newcommand{\AppendixSection}[1]{
  \begin{flushleft}
    \section{\Large#1}
    \label{app:#1}
  \end{flushleft}
}

% Headings within subsections.
% Parameter 1: Subsection name.
\newcommand{\AppendixSubSection}[1]{
  \begin{flushleft}
    \Large#1
    \label{app:#1}
    \hline
  \end{flushleft}
}

% AppendixItem to use within sections.
% Parameter 1: Item title/name.
% Parameter 2: Context.
\newcommand{\AppendixItem}[2]{
  \textbf{\color{RoyalRed}
  \begin{flushleft}
    #1:
  \end{flushleft}
  }\par\newline #2}


  %------------------------------------------------------------------------------
  %	TITLE SECTION
  %------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Het functionele paradigma is de toekomst.} % Article title
\author{%
  \textsc{Sjors Sparreboom} \\[1ex] % Your name
\normalsize Hogeschool Rotterdam \\ % Your institution
\normalsize \href{mailto:0890040@hr.nl}{0890040@hr.nl} \\[2ex] % Your email address
%\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
\textsc{Johan Bos} \\[1ex] % Second author's name
\normalsize Hogeschool Rotterdam \\ % Second author's institution
\normalsize \href{mailto:0878090@hr.nl}{0878090@hr.nl} % Second author's email address
}
\date{\today} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
  \begin{abstract}
    \noindent
    Met de komst van het internet, big data en de toenemende capaciteit van
    computers is er vernieuwde interesse in de functionele programmeertalen.
    Dit rapport onderzoekt samen met de lezer de voor en nadelen bij de
    stelling ``Het functionele paradigma is de toekomst.'' Dit gebeurt op basis
    van een literatuuronderzoek naar de relaties en verschillen van de
    heersende programmeerparadigma's. Het onderzoek beperkt zich tot het
    imperatieve en functionele paradigma. Om het functionele paradigma en zijn
    plaats binnen de informatica beter te kunnen begrijpen is er binnen dit
    onderzoek van een minimale kennisgeving van de heersende
    programmeerparadigma's uitgegaan. Ook is kennis van programmeren wenselijk,
    maar het onderzoek kan ook prima zonder deze kennis worden gevolgd.
  \end{abstract}
}

%------------------------------------------------------------------------------

\begin{document}
\nocite{*}

% Print the title
\maketitle

%------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%------------------------------------------------------------------------------

\section{Inleiding}
\label{sec:1}
\lettrine[nindent=0em,lines=3]{D}it document is een poging om de gemeenschap te
overtuigen van de significantie van functioneel programmeren alsook te
informeren wat de voordelen en nadelen zijn van dit paradigma.

Functioneel programmeren dankt zijn naam aan zijn fundamentele werking,
namelijk de toepassing van functies op argumenten. Dit beschrijft wat
het inhoudt, maar wat is nu eigenlijk een functioneel programma? Een
mooie beschrijving van een functioneel programma is die van~\textcite{src1}:
\enquote{Een functioneel programma is een functie waar de gegeven input voor
dit programma wordt behandeld als argument van een functie, welk vervolgens het
resultaat hiervan teruggeeft als output}.

Het functioneel programmeren is niet nieuw en bestaat al sinds de jaren 40. De
fundamentele werking van deze stijl van programmeren is gebaseerd op
het \textit{lambda calculus}\cite{src2,src3}. Typerend voor deze stijl is dat
functies opgebouwd zijn uit andere functies. Een mooi voorbeeld is de hoofd
functie (het programma zelf), deze is opgebouwd uit functies, welke op hun
beurt ook weer opgebouwd zijn uit functies; dit heet modulariteit een concept
dat wordt behandeld in~\cref{subsec:3-2}. Ook zijn functionele programma's
inherent parallel~\cite{src4,src12} en zijn er geen~\textit{assignments},
waardoor variabelen met een waarde niet meer kunnen veranderen
(zie~~\cref{subsec:3-1}).

In de rest van dit document zal er worden gediscussieerd over de voor- en
nadelen van deze vorm van programmeren en zal er in~\cref{sec:5} af worden
gesloten met een conclusie op de stelling~\textit{``Het functionele paradigma
is de toekomst``}.

%------------------------------------------------------------------------------

\section{Middenstuk}
\label{sec:2}

In dit middenstuk wordt er eerst korte uitleg gegeven over imperatief
programmeren. De ge\"informeerde lezer kan ervoor kiezen deze paragraaf over te
slaan, maar moet onthouden dat kennis van imperatief programmeren benodigd is
in de volgende paragrafen.

Opvolgend zal er worden gekeken naar de voordelen en nadelen van de
stelling~\textit{``Het functioneel programmeren is de toekomst''}.

%------------------------------------------------------------------------------

\subsection{Imperatief programmeren}
\label{subsec:2-1}

De term imperatief programmeren is een letterlijke beschrijving van het gedrag
dat deze programma's vertonen, namelijk het sequentieel uitvoeren van een lijst
van instructies. Echter is het vanuit deze context niet duidelijk wat een
imperatief programma is. Een duidelijke beschrijving van imperatief
programmeren wordt gegeven door~\textcite[hfdst.~3]{src6} en luidt als volgt:

\begin{quote}
  Imperatief programmeren staat in tegenstelling tot functioneel programmeren
  dichtbij de machine representatie. Het introduceert een \textit{memory state}
  die door acties van het programma kunnen worden gemodificeerd. Deze acties
  worden ook wel \textit{instructies} genoemd en een imperatief programma is
  dan ook een lijst van deze instructies.
\end{quote}

Kort samengevat heeft een imperatief programma net als een assembleer programma
een memory state concept, dat het mogelijk maakt de staat van een programma aan
te passen. Input-output acties zijn in imperatieve programma's dan ook
modificaties van het geheugen.

%------------------------------------------------------------------------------

\section{Algemene voordelen functioneel programmeren}
\label{sec:3}

Uit het onderzoek van~\textcites{src7}{src8} blijkt dat de imperatieve stijl
hedendaags nog steeds de populairste vorm van programmeren is. Wat echter opvalt
is dat er enkele functionele talen in deze resultaten (Erlang, Scala, F#,
Haskell, Clojure) staan, en dit is niet toevallig.

In~\cref{subsec:3-1} en~\cref{subsec:3-2} wordt de aanleiding van deze nieuwe
interesse in functionele talen onderzocht.

\subsection{Parallel en Gedistribueerd programmeren}
\label{subsec:3-1}

Sinds de uitvinding van het internet en \textit{big data} is er buiten de
academische wereld nieuwe interesse ontstaan in de functionele talen. Zoals
beschreven door~\textcite{src10} zijn er met komst van big data nieuwe manieren
van dataverwerking nodig, aangezien de traditionele manieren niet langer
toereikend zijn. Deze nieuwe manieren van dataverwerking baseren zich op twee
vormen van computatie die door de goedkopere en verbeterde hardware componenten
en de komst van de \textit{multi-core processor} een geheel nieuw domein aan
mogelijkheden openen; namelijk \textit{parallel} en \textit{gedistrubeerd}
computeren~\cite{src10,src11}.

Voordat wordt onderozoht waarom fuctionele talen zo geschikt zijn voor parallel
en gedistrubeerd programmeren, zal er eerst gekeken moeten worden waarom de
imperatieve stijl van programmeren niet volstaat voor deze vorm van computatie.

In~\cref{subsec:2-1} wordt al gesproken over het gebruik van een memory state in
deze imperatieve programma's. Het is nu juist het gebruik van deze muteerbare
memory state die het parallel en gedistribueerd computeren compliceert. Doordat
imperatieve programma's inherent sequentieel zijn, is de volgorde van executie
in een parallel of gedistrubeerd programma belangrijk. Wijkt de volgorde van
executie echter af, dan kan er een \textit{race conditie} ontstaan.

Race condities zijn \'e\'en van de grootste oorzaken van bugs in een parallel
en gedistrubeerd programma en ontstaan wanneer twee processen allebei
tegelijkertijd naar een stukje geheugen willen schrijven~\cite{src1}.

Het voorkomen van race race condities is niet gemakkelijk, zeker omdat in een
moderne multi-core CPU, deze CPU'S niet dezelfde \textit{througput} hebben.
In~\citetitle{src14} vertellen~\citeauthor{src14} dat in imperatieve
programma's een concept genaamd \textit{locks} (ook wel \textit{mutexes}
genoemd) is ge\"introduceerd om deze race condities tegen te gaan. Een werkende
oplossing, die echter zelf voor een nieuw probleem zorgt, namelijk
\textit{deadlock}.

Deadlock is een toestand waar elke proces wacht op een ander proces, wat
betekent dat een programma niet verder zal gaan en beland is in een oneindige
cyclus. Een programma die lijdt aan een situatie waarin er ongewenst mutaties
worden gedaan op data en een hierdoor de werking in 

Deze toestand is mogelijk  door de muteerbare data van een imperatief
programma mogelijk is. Programma's met een dergelijke situatie passen dus
buiten hun scope data en hebben een \textit{side-effect}.

Het is dus wenselijk side-effects te voorkomen in een programma, maar hoe is
dit mogelijk? Volgens~\citeauthor{src14}~\cite{src14,src15} ligt de oplossing
in het gebruik van een functionele programmeertaal. Functionele
programmeertalen hebben geen van de bovengenoemde problemen. Zo zijn ze
inherent parallel en is data in deze programma's niet muteerbaar, omdat er geen
\textit{assigment} declaratie is. Dit elimineert een belangrijke bron van bugs,
zoals de deadlock en race conditie en maakt de executie volgorde van deze
programma's irrelevant.

\subsection{Schaalbaar en Modulair}
\label{subsec:3-2}

In~\cref{sec:1} is al kort aangehaald dat functionele programma's modulair
zijn doordat functies opgebouwd zijn uit andere functies, een concept genaamd
\textit{currying}~\cite[hfdst.~5]{src16}.

Het voordeel van currying is door deze manier van functie applicatie, functies
gedeeltelijk kunnen worden toepast~\cite{src1}. Hierdoor kunnen er nieuwe
functies van oude afgeleid worden en maakt een functionele taal erg schaalbaar.

Door deze schaalbaarheid is het gemakkelijker modulair software te schrijven.
Deze manier van software maken wordt volgens vele al jaren lang beschouwt als
\'e\'n van de belangrijkste punten in het construeren van herbruikbare en
onderhoudbare software~\cite{src17}. Zo spreken ook~\textcite{src18} hun
voorkeur uit over de modulaire aanpak van het ontwerpen van software, omdat er
hierdoor toekomstige legacy problemen kunnen worden voorkomen; hierover meer
in~\cref{subsec:4-2}.

Modulair programmeren is dus een pre, maar wat is een module nu precies?
\textcite[hdfst.~6]{src16} beschrijft een module als: \enquote{Een module een
collectie van gerelateerde functies, types en typeclasses}. Wat types en
typeclasses zijn is in dit document niet relevant. Wat wel relevant is dat door
de modulariteit en schaalbaarheid van functionele programma's veel algoritmes
vaak korter zijn dan in een imperatief programma. Zo zijn hieronder twee
versies van quicksort; een imperatieve versie in C en een functionele
versie in Haskell zichtbaar.

\begin{lstlisting}[style=CStyle]
  void Sort(int input[],int left,int right)
  {
    int L = left;
    int R = right;
    int M = input[(left + right) / 2];

    do
    {
      while(input[L] < M)
      {
        L++;
      }
      while(M < input[R])
      {
        R--;
      }

      if(L <= R)
      {
        int inputLeft = input[L];
        input[L] = input[R];
        input[R] = inputLeft ;
        L++;
        R--;
      }
    } while(L < R);

    if(left < R)
    {
      Sort(input, left, R);
    }
    if(L < right)
    {
      Sort(input, L, right);
    }
  }

  void QuickSort(int input[], int length)
  {
    Sort(input, 0, length - 1);
  }
}
\end{lstlisting}

\begin{lstlisting}[style=HsStyle]
quicksort :: Ord a => [a] -> [a]
quicksort []     = []
quicksort (p:xs) =
   (quicksort lesser) ++ [p] ++ (quicksort greater)
    where
        lesser  = filter (< p) xs
        greater = filter (>= p) xs
\end{lstlisting}

Wat uit het bovengenoemde voorbeeld opvalt is dat de functionele versie veel
duidelijker en expressiever is, dan de imperatieve versie. In de imperatieve
versie is de bedoeling van het programma niet gelijk duidelijk en moet er
sequentieel over het programma worden gelopen om te begrijpen wat de bedoeling
ervan is.

%------------------------------------------------------------------------------

\section{Algemene nadelen functioneel programmeren}
\label{sec:4}

Dat de functionele stijl van programmeren tegenwoording steeds vaker wordt
overwogen, is zichtbaar in~\cref{sec:3}. Er zijn echter ook gebieden en
problemen die zich niet schikken voor een functionele aanpak van het probleem.
In~\cref{subsec:4-1} en~\cref{subsec:4-2} wordt er dan ook onderzocht waar deze
desinteresse vandaan komt.

\subsection{Portabiliteit en Beschikaarheid}
\label{subsec:4-1}

Beschikbaarheid en portabiliteit van functionele talen op verschillende
architecturen en platformen is een grote reden waarom het soms beter is te
besluiten tegen het gebruik van deze talen en te kiezen voor een imperatieve
tegenhanger. Er zijn dan ook genoeg projecten waarvan de ontwikkelaars liever
het project hadden gebouwd in een functionele taal, maar vervolgens toch
besloten te kiezen voor C of C++. E\'en van deze projecten is de taal voor de
PRL database. Volgens~\textcite{src19} besloten onderzoekers van Lucent om
deze taal te bouwen in SML, om ultimatum te kiezen C++, omdat SML niet
beschikbaar was op het Amdahl mainframe.

Dezelfde problemen zijn te analyseren voor
\textit{embedded systems}~\cite{src20}. Bij het programmeren van deze systemen
moet er rekening worden gehouden dat de architectuur van deze veel kan
verschillen van de algemene computer en dat er weinig intern geheugen
beschikbaar is~\cite{src21,src22}. Om toch goede programma's te kunnen
schrijven voor deze systemen is het dus noodzakelijk voor de programmeur om
direct het geheugen te kunnen controleren.

Functionele programma's alloceren echter in korte tijd veel geheugen. Dit is
geen probleem op systemen met genoeg geheugen, maar wordt een probleem in
een embedded omgeving. Om ervoor te zorgen dat voldoende geheugen beschikbaar
is, worden zogenaamde cells na gebruik vrijgegeven door een \textit{garbage
collector}~\cite{src23}. Deze afhankelijkheid van garbage collectie zorgt ervoor dat er
beperkte controle is over het geheugen. Dit gebrek over controle van het
geheugen maakt de meeste moderne functionele talen niet geschikt voor embedded
systemen, zeker de systemen met weinig geheugen of harde \textit{real-time}
beperkingen~\cite{src24}.

\subsection{Legacy code en Infrastructuur}
\label{subsec:4-2}

Er is veel commerci\"ele software in de omloop dat is gedateerd en kan
profiteren van de voordelen van functioneel programmeren. Om deze voordelen te
benutten moet de huidige infrastructuur van deze systemen worden veranderd, wat
in de praktijk een nogal lastig en gevoelig onderwerp blijkt te zijn. In de
systemen is namelijk hevig ge\"investeerd en de werking ervan is vaak verworven
met de gebruiksdoeleinde~\cite{src18,src25}.

Vervanging is dus lastig, zeker als er nagegaan wordt dat na decennia lang
schrijven van software, systemen vaak samengesteld zijn uit componenten. Veel
van deze componenten zijn geschreven in een imperatieve programmeertaal zoals C
of C++. Hierdoor is een \textit{foreign function interface} met C of C++ vaak
noodzakelijk zijn om de achterwaartse comptabiliteit te garanderen\cite{src19}.
Echter door de isolationistische natuur van functionele talen zijn deze foreign
function interfaces moeilijk implementeerbaar en word er vaak nog steeds
gekozen voor makkelijk koppelbare imperatieve programmeertaal.

\section{Conclusie}
\label{sec:5}

In dit document is er gediscussieerd over de voordelen en nadelen van het
functioneel programmeren. In~\cref{sec:3} wordt duidelijk dat met de komst van
het internet en de ontwikkelingen op hardware gebied er nieuwe interesse is
voor functioneel programmeren.

De schaalbaarheid, modulariteit, niet muteerbare datastructuren en het inherent
vermogen om parallel expressies te evalueren maakt functioneel programmeren een
programmeertsstijl die zeer geschikt is om software te schrijven voor de 21$^e$
eeuw.

Het is echter misschien iets te vroeg om te stellen dat de functionele stijl
van programmeren de toekomst is. Zo is er nog steeds geen functionele opmars
zichtbaar in de embedded systems hoek en worden legacy problemen in grote
commerci\"ele software systemen nog altijd imperatief opgelost.

Er is een glansrijke toekomst voor de functionele stijl van programmer, maar
vooralsnog moet er goed gekeken worden naar de probleemstelling en het doel
voor er paradigmatisch besluit kan worden genomen.

%------------------------------------------------------------------------------
%	REFERENCE LIST
%------------------------------------------------------------------------------

\printbibliography

\clearpage
\onecolumn

%------------------------------------------------------------------------------
%	APPENDIX
%------------------------------------------------------------------------------

\begin{appendices}

  \AppendixSection{Terminologie}

  \AppendixItem{Assignment}{
    Een \textit{assignment} stelt de waarde in die is opgeslagen in de
    opslaglocatie dat wordt aangeduid met een variabelenaam.
  }


  \AppendixItem{Big Data}{
    Data sets die zo enorm en complex zijn dat traditionele
    dataverwerkingssoftware niet langer toereikend zijn.
  }

  \AppendixItem{Deadlock}{
    \textit{Deadlock}, zoals te zien in~\cref{fig:./fig/deadlock.png} is een
    toestand waarin elk proces wacht op een ander proces. Deze toestand kan
    voorkomen wanneer de locks worden verkregen in de verkeerde volgorde.
    \fig{0.3}{./fig/deadlock.png}{Deadlock (source:
    wikipedia.org/wiki/Deadlock)}
  }

  \AppendixItem{Foreign function interface}{
    Een \textit{foreign function interface} (FFI) is een mechanisme waarmee een
    programma dat in een programmeertaal is geschreven, routines kan noemen of
    gebruik kan maken van services die in een andere taal zijn geschreven.
  }

  \AppendixItem{Gedistribueerde computatie}{
    Een \textit{gedistribueerd computatie} is een computatie waar een enkele
    taak wordt opgesplitst in meerdere subtaken. Deze subtaken worden
    vervolgens gedistribueerd over verschillende nodes in een netwerk en
    onafhankelijk berekent. Als al deze computaties gedaan zijn zullen deze
    onafhankelijke berekeningen worden samengevoegd tot \'e\'en resultaat,
    zoals te zien in~\cref{fig:./fig/distributed_process.png}.
    \fig{0.7}{./fig/distributed_process.png}{Gedistribueerd proces}
  }

  \newpage

  \AppendixItem{Lock/Mutex}{
    \textit{Lock}, zoals te zien in~\cref{fig:./fig/lock.png} is een mechanisme
    om het benaderen van een bron in een omgeving te beperken.
    \fig{0.3}{./fig/lock.png}{Lock/Mutex}
  }

  \AppendixItem{Memory leak}{
    Een \textit{Memory leak} betekent dat een programma meer geheugen toewijst
    dan nodig voor de executie. Dit kan over tijd erg oplopen aangezien dit
    niet gebruikte geheugen nooit opnieuw toegewezen kan worden, zonder het
    wordt gedealloceerd.
  }

  \AppendixItem{Multi-core processor}{
    \textit{Multi-core processoren}, bestaan uit verschillende processoren en
    gedeeld geheugen, zie~\cref{fig:./fig/mutlicore.png}. Deze processoren zijn
    sneller en hebben een lager energieverbruik dan de single-core processor,
    zie~\cref{fig:./fig/singlecore.png}, echter is het programmeren voor deze
    architectuur een stuk lastiger.
    \fig{0.3}{./fig/mutlicore.png}{Multi-core processor}
  }

  \AppendixItem{Memory state}{
    \textit{Memory state} alle opgeslagen ingegeven waardes van een programma
    als variabelen of constanten. Bij het analyseren van de status van dit
    programma kunnen programmeurs deze opgeslagen ingegeven waardes bekijken.
  }

  \AppendixItem{Parallelle computatie}{
    Een \textit{parallelle computatie} is een vorm van computatie waarin
    meerdere calculaties simultaan kunnen worden uitgevoerd. Deze vorm van
    executie is sinds de komst van de multi-core processor,
    zie~\cref{fig:./fig/mutlicore.png} het dominante paradigma in computer
    architectuur.

    Een parallelle executie van een proces wordt gedaan door gebruik te maken
    van threads, zie~\cref{fig:./fig/thread.png}.
    In~\cref{fig:./fig/parallel_process_cores.png} is een parallelle
    executie op een multi-core processor zichtbaar
    (\cref{fig:./fig/mutlicore.png}).

    Wat opvalt zijn de extra kernen van deze architectuur, die een
    single-core processor, zoals te zien in~\cref{fig:./fig/singlecore.png}
    niet heeft. Als deze verschillende kernen zinnig werk tegelijkertijd doen
    kan dit het gehele proces versnellen.
    \fig{0.3}{./fig/parallel_process_cores.png}{Parall proces}
  }

  \newpage

  \AppendixItem{Process \& Thread}{
    Een \textit{thread} is de kleinste sequentie van een programma dat
    onafhankelijk kan opereren. Hoe een proces en thread opereren hangt af van
    de implementatie van het operatie systeem. De meeste voorkomende
    implementatie is dat een thread een onderdeel is van het proces, zoals te
    zien in~\cref{fig:./fig/thread.png}.
    \fig{0.2}{./fig/thread.png}{Thread}
  }

  \AppendixItem{Race conditie}{
    Twee processen P1 en P2, kunnen beide schrijven naar de variabel
    $tmp$. De intentie van de programmeur is dat zowel proces P1 als P2
    $tmp$ van een waarde voorziet, deze vervolgens gelijk te gebruiken en een
    uiteindelijke waarde voor $y$ en $z$ te presenteren. De executie van
    algoritme~\cref{algo:algo1} levert de volgende waardes voor $y$ en $z$:
    \begin{gather*}
      y = 24, z = 2055
    \end{gather}

    Echter doordat de processen op verschillende snelheden kunnen draaien, doet
    zich een situatie voor, zoals te zien in algoritme~\cref{algo:algo2} waar
    de volgorde van executie niet wordt uitgevoerd zoals de programmeur had
    bedoeld. De executie van levert de volgende waardes voor $y$ en $z$:
    \begin{gather*}
      y = 4096, z = 2055
    \end{gather}
    Zoals te zien is dit niet de juiste waarde voor $y$. Deze situatie wordt
    ook wel een race conditie genoemd in de informatica.

    \begin{multicols}{2}
      \begin{algorithm}[H]
        \caption{Programmeurs intentie}
        \label{algo:algo1}
        \begin{algorithmic}
          \Variables
          \State $tmp$
          \EndVariables
          \begin{multicols}{2}
            \Procedure{P1}{}
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \State $tmp = 12 $
            \State $y = 2 \times tmp$
            \EndProcedure
            \columnbreak
            \Procedure{P2}{}
            \State $tmp = 2048$
            \State $z = tmp + 7$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \EndProcedure
          \end{multicols}
        \end{algorithmic}
      \end{algorithm}
      \columnbreak
      \begin{algorithm}[H]
        \caption{Race conditie}
        \label{algo:algo2}
        \begin{algorithmic}
          \Variables
          \State $tmp$
          \EndVariables
          \begin{multicols}{2}
            \Procedure{P1}{}
            \State $tmp = 12 $
            \State $\mathbf{.}$
            \State $y = 2 \times tmp$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \EndProcedure
            \columbreak
            \Procedure{P2}{}
            \State $\mathbf{.}$
            \State $tmp = 2048$
            \State $\mathbf{.}$
            \State $z = tmp + 7$
            \State $\mathbf{.}$
            \EndProcedure
          \end{multicols}
        \end{algorithmic}
      \end{algorithm}
    \end{multicols}
  }

  \AppendixItem{Real-time proces}{
    Een \textit{real-time proces} is een proces waarin een programma het
    resultaat moet garanderen binnen een bepaalde tijd.
  }

  \AppendixItem{Side-effect}{
    Binnen de informatica heeft een programma, functie of expressie een
    \textit{side-effect} wanneer het een waarde buiten zijn scope aanpast of
    een interactie heeft met zijn aanroep functies of de rest van het programma
    zonder een waarde te retourneren.
  }

  \AppendixItem{Single-core Processor}{
    \textit{Single-core processoren} hebben maar 1 processor direct verbonden
    aan het geheugen. Deze processoren zijn gemakkelijk te programmeren, maar
    hebben echter een lagere hoog energieverbruik en een lage prestatie, in
    tegenstelling tot de multi-core processor,
    zie~\cref{fig:./fig/mutlicore.png}.
    \fig{0.3}{./fig/singlecore.png}{Single-core processor}
  }

  \AppendixItem{Throughput}{
    \textit{Throughput} is de maximale snelheid waarop \textit{iets} kan worden
    verwerkt.
  }

  \clearpage

  \AppendixSection{Deelopdracht 1}

  \AppendixItem{Doelgroep}{
    De doelgroep van het artikel zijn mensen met een interesse voor
    ontwikkelingen in de techniek en het functioneel programmeren. Het artikel
    gaat uit van mensen met een technische achtergrond, maar door de duidelijke
    referenties en de handige bijlage, is het ook goed mogelijk voor mensen
    zonder enige voorgaande technische kennis om dit artikel te volgen.
  }

  \AppendixItem{Doel}{
    Het doel van dit artikel, ook wel \textit{factchecker} genoemd is om de
    lezer te informeren over de voor- en nadelen van het functioneel
    programmeren.
  }

  \AppendixItem{Wat is het thema?}{
    Functioneel programmeren is een programmeerparadigma dat technische mensen
    met een technische of mathematische achtergrond effici\"ente, korte en
    elegante programma's laat schijven die inherent parallel zijn.
  }

  \AppendixItem{Waar gaat het stuk over?}{
    {\setlength{\parindent}{0cm}
    \starttext \noindentation
    \textbf{De stelling:} Het functionele paradigma is de toekomst.\\\\
    \textbf{Deelvragen:}
    \begin{itemize}
      \item Wat is functioneel programmeren
      \item Wat is imperatief programmeren
      \item Waarom de hernieuwde interesse in functioneel programmeren?
      \item Wat zijn de voor- en nadelen van functioneel programmeren ten
        opzicht van imperatief programmeren
    \end{itemize}
    }
  }

  \AppendixItem{Wat zijn de kernantwoorden?}{
    {\setlength{\parindent}{0cm}
    \textbf{Deelvraag 1:} Functioneel programmeren is een programmeerparadigma
    dat zichzelf uitdrukt in de vorm van functies.\\
    \textbf{Deelvraag 2:} Imperatief programmeren is een programmeerparadigma
    waar programma's opgesteld zijn in de vorm van instructies die direct
    uitgevoerd kunnen worden.\\
    \textbf{Deelvraag 3:} Door de komst van big data en de multicore processor
    is er hernieuwde interesse in het functionele paradigma.\\
    \textbf{Deelvraag 4 (voordeel):} Functionele programma's zijn inherent
    parallel waardoor deze in de tijd van de multicore processor en
    gedistrubeerde omgevingen ideaal zijn voor het \textit{side-effect} vrij
    uitvoeren van programma's.\\
    \textbf{Deelvraag 4   (nadeel):} Voor het aanpassen van legacy systemen en
    schrijven van \textit{firmware} zijn functionele programmeertalen nog
    steeds niet geschikt en blijken imperatieve programmeertalen nog steeds een
    beter alternatief.
    }
  }

  \clearpage

  \AppendixSection{Deelopdracht 2}

  \AppendixSubSection{Voor- Sjors Sparreboom}

  \AppendixItem{Bron 1: Wetenschappelijk artikel}{
    \begin{table}[htpb]
      \centering
      \begin{tabular}{|l|l|}
        \hline
        Titel & Why functional programming matters \\
        \hline
        Auteur, Jaar & John hughes, 1989 \\
        \hline
        URL &
        \href{https://www.researchgate.net/profile/John_Hughes13/publication/2452204_Why_Functional_Programming_Matters/links/00b4952bf430e24d78000000/Why-Functional-Programming-Matters.pdf}{Why
        Functional Programming Matters} \\
        \hline
      \end{tabular}
    \end{table}
  }

  \AppendixItem{Toesting van betrouwbaarheid}{
    Research gate is een sociale netwerk site voor wetenschappers en
    onderzoekers, waar er artikelen worden uitgewisseld, vragen gesteld en
    vragen worden beantwoord. Het is het grootste academische sociale netwerk,
    volgens
    \href{https://en.wikipedia.org/wiki/Times_Higher_Education}{Times Higher
    Education}
  }

  \AppendixItem{Hoe ondersteunt deze bron mijn argumentatie?}{
    Deze bron legt heel gemakkelijk uit wat functioneel programmeren is en wat
    de meerwaarde hiervan zijn. Zo geeft het een duidelijke uitleg over functie
    applicatie en compositie.
  }

  \AppendixItem{Bron 2: Videocast}{
    \begin{table}[htpb]
      \centering
      \begin{tabular}{|l|l|}
        \hline
        Titel & Programming in the Age of Concurrency: Software Transactional Memory \\
        \hline
        Auteur, Jaar & Simon Peyton Jons Tim Harris, 2017 \\
        \hline
        URL &
        \href{https://channel9.msdn.com/shows/Going+Deep/Programming-in-the-Age-of-Concurrency-Software-Transactional-Memory/}{Programming
        in the Age of Concurrency: Software Transactional Memory} \\
        \hline
      \end{tabular}
    \end{table}
  }

  \AppendixItem{Toesting van betrouwbaarheid}{
    Channel 9 is een gemeeschapswebsite, waar diverse grote sprekers, zoals
    Erik Mijer, Bill Gates en Mark Russinovich hebben gesproken. De
    bovengenoemde twee sprekers,
    \href{:https://www.microsoft.com/en-us/research/people/simonpj/?from=http\%3A\%2F\%2Fresearch.microsoft.com\%2F\%7Esimonpj}{Simon
    Peyton Jones} en \href{https://www.bscmsrc.eu/people/tim-harris}{Tim Harris}
    zijn beide researchers van Cambridge in dienst van microsoft. Tevens is
    Simon Peyton Jones \'e\'en van de makers van de functionele programmeertaal
    Haskell en een
    \href{https://royalsociety.org/people/simon-peyton-jones-12889/}{Fellow of
    the Royal Society}.
  }

  \AppendixItem{Hoe ondersteunt deze bron mijn argumentatie?}{
    Deze bron legt heel goed uit wat de hedendaagse problemen zijn met het
    imperatief programmeren en hoe functioneel programmeren hier een oplossing
    voor kan bieden.
  }

  \clearpage

  \AppendixItem{Bron 3: Wetenschappelijk boek}{

    \begin{table}[htpb]
      \centering
      \begin{tabular}{|l|l|}
        \hline
        Titel & The Lambda Calculus: Its Syntax and Semantics \\
        \hline
        Auteur, Jaar & Henk Barendregt, 1984 \\
        \hline
        URL &
        \href{https://www.amazon.com/Calculus-Semantics-Studies-Foundations-Mathematics/dp/0444875085}{The Lambda Calculus: Its Syntax and Semantics} \\
        \hline
      \end{tabular}
    \end{table}
  }

  \AppendixItem{Toesting van betrouwbaarheid}{
    Het boek, in de Elsevier gepubliceerd als journal, maakt deel uit van de
    series \textit{Studies in Logic and the Foundations of Mathematics}. Het is
    een artikel geschreven door Hoog leraar
    \href{https://nl.wikipedia.org/wiki/Henk_Barendregt}{Henk Barendregt} die
    in 2002 de
    \href{https://nl.wikipedia.org/wiki/Spinozapremie}{spinozaprijs} heeft
    ontvagen.
  }

  \AppendixItem{Hoe ondersteunt deze bron mijn argumentatie?}{
    Deze bron legt heel goed uit dat dat \textit{lamda calculus} Turingvolledig
    is. Het toont aan door vele voorbeelden en textuele beshrijving dat elk
    probleem wat opgelost kan worden door een turingmachine ook opgelost kan
    worden met lambda calculus met als voordeel dat de expressies inherent
    parallel gevalueerd kunnen worden, zonder \textit{side-effects}.
  }

  \clearpage

  \AppendixSubSection{Tegen- Sjors Sparreboom}

  \AppendixItem{Bron 1: Thesis}{
    \begin{table}[htpb]
      \centering
      \begin{tabular}{|l|l|}
        \hline
        Titel & Functional Programming and Embedded Systems \\
        \hline
        Auteur, Jaar & Malcolm Wallace, 1995 \\
        \hline
        URL &
        \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.29.5561\&rep=rep1\&type=pdf}{Functional
        Programming and Embedded Systems} \\
        \hline
      \end{tabular}
    \end{table}
  }

  \AppendixItem{Toesting van betrouwbaarheid}{
    Deze bron is een succesvol ingeleverde thesis voor de graad \textit{DPhil
    in Compure Science} en is afkomstig en gepubliceerd door de York
    universiteit in 1995.
  }

  \AppendixItem{Hoe ondersteunt deze bron mijn argumentatie?}{
    Deze bron legt goed uit wat embedded systemen zijn en waar er rekening mee
    gehouden moet worden als er firmware geschreven moeten worden voor deze
    systemen. Het benadrukt tevens hoe functioneel programmeren gebruikt kan
    worden voor het schrijven van firmware voor embedded systemen. Ook geeft
    de thesis veel pro en contra argumenten voor het functioneel programmeren
    op een embedde systeem.
  }

  \AppendixItem{Bron 2: Wetenschappelijk artikel}{
    \begin{table}[htpb]
      \centering
      \begin{tabular}{|l|l|}
        \hline
        Titel & Why No One Uses Functional Languages \\
        \hline
        Auteur, Jaar & Philip Wadler, 1998 \\
        \hline
        URL &
        \href{https://pdfs.semanticscholar.org/6261/a3935024a4df90e20a6356257ebc808082fa.pdf}{Why
        No One Uses Functional Languages} \\
        \hline
      \end{tabular}
    \end{table}
  }

  \AppendixItem{Toesting van betrouwbaarheid}{
    Deze bron is geschreven door professor van theoretische computer
    wetenschap, \href{http://homepages.inf.ed.ac.uk/wadler/}{Philip Wadler}.
    Professor Wadler is \'e\'en van de makers van Haskell en heeft gezorgd voor
    de introductie van type classes en monads in functioneel programmeren.

    Philip wadler werkt daarnaast momenteel als wetenschapper bij het
    vooraanstaande \href{https://www.bell-labs.com/}{Bell Labs}, waar onder
    andere de eerste transistor uitgevonden is, de programmeertalen C/C++ zijn
    ontwikkeld en UNIX is geboren.
  }

  \AppendixItem{Hoe ondersteunt deze bron mijn argumentatie?}{
    Deze bron beschrijft heel goed wat momenteel de volledige transitie
    naar het functionele paradigma tegenhoudt voor veel ondernemingen en
    programmeurs.
  }

  \clearpage

  \AppendixItem{Bron 3: Wetenschappelijk artikel}{
    \begin{table}[htpb]
      \centering
      \begin{tabular}{|l|l|}
        \hline
        Titel & Scheduling Garbage Collection in Real-time Systems \\
        \hline
        Auteur, Jaar & Martin Kero \& Simon Aittamaa  \\
        \hline
        URL &
        \href{https://www.researchgate.net/profile/Simon_Aittamaa/publication/221656661_Scheduling_garbage_collection_in_real-time_systems/links/0c960523b08e35c00e000000/Scheduling-garbage-collection-in-real-time-systems.pdf}{Scheduling Garbage Collection in Real-time Systems} \\
        \hline
      \end{tabular}
    \end{table}
  }

  \AppendixItem{Toesting van betrouwbaarheid}{
    De Lule\r{a} Universiteit van Technologie in Zweden is een erkende
    universiteit en de validatie van artikelen verloopt dat ook via deze,
    voordat er over wordt gegaan op publicatie. Daarnaast zijn zowel
    \href{https://www.linkedin.com/in/martinkero/}{Martin Kero} en
    \href{https://www.linkedin.com/in/simon-aittamaa-7a489247/}{Simon Aittamaa}
    in het bezit van een Phd in computer wetenschappen.
  }

  \AppendixItem{Hoe ondersteunt deze bron mijn argumentatie?}{
    Deze bron helpt bij het vinden van argumenten over hardware en software
    beperkingen in real-time systemen en de problemen die een garbage collector
    introduceert.
  }

  \clearpage

  \AppendixSection{Deelopdracht 3}

  \AppendixSubSection{Rapport voor feedback}
    \AppendixItem{Inleiding}{
      \lettrine[nindent=0em,lines=3]{V}oor het maken van programma's wordt er gebruik gemaakt van programmeertalen.  Door het gebruik van een programmeertaal is het
    mogelijk voor een programmeur om een computer te voorzien van instructies en zo
    de gigantische rekenkracht van het apparaat te benutten. Er zijn door de jaren
    heen veel programmeertalen ontwikkelt. Sommige revolutionair en vernieuwend,
    andere een uitbreiding op reeds bestaande talen. Veel van deze programmeertalen
    delen dezelfde kenmerken en kunnen worden geclassificeerd onder een
    paradigma.

    Het is daarom van essentieel belang dat een keuze voor een paradigma
    afhankelijk is van een correcte probleem- of doelstelling. Zo wordt er vanuit
    de academische en wetenschappelijke hoek al jaren aangezet tot een transitie
    naar het functionele paradigma, maar worden functionele programmeertalen, zoals
    Haskell en Lisp vaak als een onconventionele, onwerkbare vorm van software
    ontwikkeling gezien. Echter wordt er momenteel met de komst van big data en
    cloud computing een nieuwe effici\"ente manier van dataverwerking toegepast die
    veelal gebruik maakt van parallel, gelijktijdig en gedistribueerd programmeren.

    Deze oplossingen schikken zich vaak voor een functionele aanpak van het
    probleem, maar de achterliggende infrastructuur is vaak imperatief en
    objectgeori\"enteerd waardoor een combinatie veelal uitgesloten is, maar wel
    wenselijk.
  }

    \AppendixItem{Middenstuk}{
      In dit middenstuk zal er een korte uitleg worden gegeven wat de imperatieve en
    functionele programmeerparadigma's inhouden. Opvolgend zal er worden gekeken
    naar twee kanten van deze stelling, namelijk de voor en tegenargumentatie.

    Om de plaats van het functionele programmeerparadigma beter te kunnen
    begrijpen, zal er eerst gekeken moeten worden naar de andere dominante
    paradigma's in de industrie. De paradigma's die kort besproken zullen worden
    zijn: het imperatieve en functionele programmeerparadigma.
  }

    \AppendixItem{Imperatief programmeren}{
      Imperatief programmeren houdt in dat een programma een structuur beschrijft
    volgens het Turingmodel. Dit programma wordt door de computer ingelezen in het
    geheugen om het in kleine delen sequentieel uit te voeren. De tussentijdse
    berekeningen worden in een imperatieve taal als data opgeslagen in het
    geheugen. Deze data kan vervolgens worden opgehaald en gemuteerd door elk
    volgende instructie die toegang heeft tot deze data, totdat er een antwoord
    wordt gepresenteerd. Imperatieve programmeertalen zijn door deze eigenschap om
    de huidige staat van het programma aan te passen zeer geschikt voor het
    programmeren van computer hardware. Zo zijn CPU's imperatieve executie machines
    en compilers vertalen direct naar deze taal. Dit is de reden dat imperatief
    programmeren hedendaags de gangbare manier van programmeren is.
  }

    \AppendixItem{Functioneel programmeren}{
      Functioneel programmeren is een paradigma dat niet nieuw is, maar al sinds de
    jaren 40 bestaat. Het is een paradigma wat is ontstaan uit het
    lambda calculus, wat Turingvolledig is. Kenmerkend voor functioneel
    programmeren is het programmeren met functies, het vermijden van globale staat,
    de niet muteerbare data structuren en een executie model waarin de evaluatie
    volgorde niet uitmaakt.
  }

    \AppendixItem{Algemene voordelen functioneel programmeren}{

      Nu er kort uitleg is gegeven over imperatieve en functionele talen kunnen we
    kijken naar de verschillen, in het bijzonder de voor en nadelen. Om de
    verschillen echter goed te begrijpen is het handig om te weten dat op het
    moment van schrijven van dit rapport het dominante paradigma in de industrie de
    imperatieve manier van programmeren is. Het is echter pas sinds kort dat er
    hernieuwde interesse is ontstaan in de functionele talen vanwege de
    expressiviteit en het vermogen van deze talen om foutloos gelijktijdig
    programma's uit te voeren. Deze eigenschappen sluiten heel goed aan bij de
    belangen van veel bedrijven die met de komst van het internet,
    cloud computing en big data over data beschikken die zo omvangrijk is dat
    de traditionele data verwerkingssoftware niet toereikend genoeg is om hiermee
    om te gaan. De oplossing: het verdelen van de data over verschillende
    multi-core processoren, zodat er betere prestaties kunnen worden behaald en de
    verwerking sneller verloopt. Dit heet in de informatica gedistribueerd
    programmeren.

    Gedistribueerd programmeren is een complex onderwerp in de informatica en niet
    zonder enige risico's. Doordat er meerdere multi-core processoren aangesproken
    worden, wat tevens gelijktijdig kan gebeuren, moet er goed nagedacht worden
    over de evaluatie volgorde. Doordat de aangesproken processoren niet dezelfde
    throughput hebben zijn uitspraken over ruimte en tijd complexiteit moeilijk
    voor een programmeur. Zeker als we er vanuit kunnen gaan dat het meest
    gebruikte paradigma in de industrie de imperatieve stijl van programmeren is.
    Het imperatief programmeren is inherent sequentieel en data is muteerbaar wat
    het correct uitvoeren van een programma nog meer bemoeilijkt door eventuele
    data races. Om data races te voorkomen zijn er in vele imperatieve
    programmeertalen locks of mutexes ge\"introduceerd met als doel het correct
    afhandelen van de executievolgorde van een imperatief programma. Echter zijn de
    ge\"introduceerde oplossingen niet zonder bijwerkingen, denk aan de deadlock.

    Functionele programmeertalen hebben echter veel van deze problemen niet. Zo
    zijn functionele talen niet afhankelijk van de evaluatie volgorde en zijn er
    geen locks of mutexes, wat ze uitsluit voor deadlocks. Dit maakt het
    mogelijk om verschillende stukken van een expressie parallel te evalueren,
    wat een pre is voor gedistribueerd programmeren. Tevens is de data in de
    functionele programmeertalen niet muteerbaar, wat inhoudt dat er geen
    bijwerkingen kunnen ontstaan, waardoor data races niet tot nauwelijks voor
    kunnen komen in deze talen.

    De functionele programmeertalen zijn ook erg schaalbaar, zo zijn bepaalde
    algoritmes in functionele programmeertaal vaak minder regels code dan in een
    imperatieve taal, doordat functionele talen vaak een hogere abstractie
    hanteren, denk hierbij aan het gebruik van hogere graads functies. Dit zorgt
    voor een duidelijker en beter herbruikbaar systeem, waar elk stuk code een
    eigen, gescheiden verantwoordelijkheid heeft, dit heet modulariteit.
  }

    \AppendixItem{Algemene nadelen functioneel programmeren}{
      Dat functioneel programmeren tegenwoordig voor steeds meer situaties en
    problemen een gangbare oplossing is, hebben we besproken. Echter zijn er ook
    situaties en problemen die zich niet schikken voor een functionele oplossing.
    E\a'en van deze situaties is als er programma's (ook wel firmware genoemd)
    moeten worden geschreven voor embedded systemen. Embedded systemen zijn vaak
    gemaakt voor het uitvoeren van specifieke taken, dit in tegenstelling tot
    een computer voor algemeen gebruik. Doordat embedded systemen veelal gemaakt
    zijn voor het uitvoeren van specifieke taken zijn er veel meer
    processorarchitecturen. Deze grote verschillen in processorarchitectuur en de
    beperkte interne geheugen die deze chips vaak hebben, maakt ze niet erg
    geschikt voor het schrijven van firmware in een functionele programmeertaal,
    aangezien functionele talen meer geheugen gebruiken dan andere paradigma's.

    Ook de garbage collector van de functionele talen kan worden gezien als een
    enorme beperking aangezien de programmeur het onderliggende geheugen niet kan
    controleren. Zo zijn de meeste functionele programmeertalen aanzienlijk
    langzamer zonder een goed geoptimaliseerde compiler ten opzichte van
    imperatieve programmeertalen. Veel van dit verlies in snelheid kan worden
    verklaard door de focus op abstractie van de functionele talen. Door dit hogere
    niveau van programmeren duurt een translatie naar machine code door de compiler
    vaak langer dan de translatie van imperatieve talen.
  }

  \AppendixItem{Conclusie} {
  }

  \clearpage

  \AppendixSubSection{Rapport na feedback}

    \AppendixItem{Inleiding}{
      \lettrine[nindent=0em,lines=3]{}
        Voor het maken van programma's wordt er gebruik gemaakt van
        programmeertalen. Door het gebruik van een programmeertaal is het
        mogelijk voor een programmeur om een computer te voorzien van
        instructies en zo de gigantische rekenkracht van het apparaat te
        benutten. Er zijn door de jaren heen veel programmeertalen ontwikkelt.
        Sommige revolutionair en vernieuwend, andere een uitbreiding op reeds
        bestaande talen. Veel van deze programmeertalen delen dezelfde
        kenmerken en kunnen worden geclassificeerd onder een
        \texit{'paradigma'}.

        Het is daarom van essentieel belang dat een keuze voor een paradigma
        afhankelijk is van een correcte probleem- of doelstelling. Zo wordt er
        vanuit de academische en wetenschappelijke hoek al jaren aangezet tot
        een transitie naar het functionele paradigma, maar worden functionele
        programmeertalen, zoals Haskell en Lisp vaak als een onconventionele,
        onwerkbare vorm van software ontwikkeling gezien. Echter wordt er
        momenteel met de komst van \textit{big data'} en
        \textit{'cloud computing'} een nieuwe effici\"ente manier van
        dataverwerking toegepast die veelal gebruik maakt van parallel,
        gelijktijdig en gedistribueerd programmeren.

        Deze oplossingen schikken zich vaak voor een functionele aanpak van het
        probleem, maar de achterliggende infrastructuur is vaak imperatief en
        objectgeori\"enteerd, waardoor een combinatie veelal uitgesloten is,
        maar wel wenselijk.

        Dit rapport bekijkt samen met de lezer de voor en nadelen bij de
        stelling \textit{'Het functionele paradigma is de toekomst.'} Dit
        gebeurt op basis van een literatuuronderzoek naar de relaties en
        verschillen van de heersende programmeerparadigma's in de industrie.
        Het onderzoek beperkt zich tot het imperatieve en functionele
        paradigma. Om het functionele paradigma en zijn plaats binnen de
        informatica beter te kunnen begrijpen is er binnen dit onderzoek van
        een minimale kennisgeving van de heersende programmeerparadigma's in de
        industrie uitgegaan. Ook is kennis van programmeren wenselijk, maar kan
        het onderzoek ook prima zonder deze kennis worden gevolgd.
      }

    \AppendixItem{Middenstuk}{
      In dit middenstuk zal er een korte uitleg worden gegeven wat de imperatieve
    en functionele programmeerparadigma's inhouden. Opvolgend zal er worden 
    gekeken naar twee kanten van deze stelling, namelijk de voor en 
    tegenargumentatie.

    Om de plaats van het functionele programmeerparadigma beter te kunnen 
    begrijpen, zal er eerst gekeken moeten worden naar de andere dominante 
    paradigma's in de industrie. De paradigma's die kort besproken zullen 
    worden zijn: het imperatieve en functionele programmeerparadigma.
  }

    \AppendixItem{Imperatief programmeren}{
      Imperatief programmeren houdt in dat een programma een structuur
      beschrijft volgens het Turing-model. Dit programma wordt door de computer
      ingelezen in het geheugen om het in kleine delen \textit{'sequentieel'}
      uit te voeren. De tussentijdse berekeningen worden in een imperatieve
      taal als data opgeslagen in het geheugen. Deze data kan vervolgens worden
      opgehaald en \textit{'gemuteerd'} door elk volgende instructie dit
      toegang heeft tot deze data, totdat er een antwoord wordt gepresenteerd.
      Imperatieve programmeertalen zijn door deze eigenschap om de huidige
      staat van het programma aan te passen zeer geschikt voor het programmeren
      van computer hardware. Zo zijn CPU's imperatieve executie machines en
      compilers vertalen direct naar deze taal. Dit is de reden dat imperatief
      programmeren hedendaags de gangbare manier van programmeren is.
    }

    \AppendixItem{Functioneel programmeren}{
      Functioneel programmeren is een paradigma dat niet nieuw is, maar al
      sinds de jaren 40 bestaat. Het is een paradigma wat is ontstaan uit het
      \textit{'lambda calculus'}, wat Turingvolledig is. Kenmerkend voor
      functioneel programmeren is het programmeren met functies, het vermijden
      van globale staat, de niet muteerbare data structuren en een executie model
      waarin de evaluatie volgorde niet uitmaakt.
    }

    \AppendixItem{Algemene voordelen functioneel programmeren}{
      Nu er kort uitleg is gegeven over imperatieve en functionele talen kunnen
      we kijken naar de verschillen, in het bijzonder de voor en nadelen. Om de
      verschillen echter goed te begrijpen is het handig om te weten dat op het
      moment van schrijven van dit rapport het dominante paradigma in de
      industrie de imperatieve manier van programmeren is. Het is echter pas
      sinds kort dat er hernieuwde interesse is ontstaan in de functionele
      talen vanwege de expressiviteit en het vermogen van deze talen om
      foutloos gelijktijdig programma's uit te voeren. Deze eigenschappen
      sluiten heel goed aan bij de belangen van veel bedrijven die met de komst
      van het internet, \textit{'cloud computing'} en \textit{'big data'} over
      data beschikken die zo omvangrijk is dat de traditionele data
      verwerkingssoftware niet toereikend genoeg is om hiermee om te gaan. De
      oplossing: het verdelen van de data over verschillende multi-core
      processoren, zodat er betere prestaties kunnen worden behaald en de
      verwerking sneller verloopt. Dit heet in de informatica gedistribueerd
      programmeren.

      Gedistribueerd programmeren is een complex onderwerp in de informatica
      niet zonder enige risico's. Doordat er meerdere multi-core processoren
      aangesproken worden, wat tevens gelijktijdig kan gebeuren, moet er goed
      nagedacht worden over de evaluatie volgorde. Doordat de aangesproken
      processoren niet dezelfde \textit{'throughput'} hebben zijn uitspraken
      over ruimte en tijd complexiteit moeilijk voor een programmeur. Zeker als
      we er vanuit kunnen gaan dat het meest gebruikte paradigma in de
      industrie de imperatieve stijl van programmeren is. Het imperatief
      programmeren is inherent sequentieel en data is muteerbaar wat het
      correct uitvoeren van een programma nog meer bemoeilijkt door eventuele
      \textit{'data races'}. Om data races te voorkomen zijn er in vele
      imperatieve programmeertalen \textit{'locks'} of \textit{'mutexes'}
      ge\"introduceerd, met als doel het correct afhandelen van de
      executievolgorde van een imperatief programma. Echter zijn de
      ge\"introduceerde oplossingen niet zonder bijwerkingen, denk aan de
      \textit{'deadlock'}.

      Functionele programmeertalen hebben echter veel van deze problemen niet.
      Zo zijn functionele talen niet afhankelijk van de evaluatie volgorde en
      zijn er geen \textit{'locks'} of \textit{'mutexes'}, wat ze uitsluit voor
      \textit{'deadlocks'}. Dit maakt het mogelijk om verschillende stukken van
      een \textit{'expressie'} parallel te evalueren, wat een pre is voor
      gedistribueerd programmeren. Tevens is de data in de functionele
      programmeertalen niet muteerbaar, wat inhoudt dat er geen bijwerkingen
      kunnen ontstaan, waardoor data \textit{'races'} niet tot nauwelijks voor
      kunnen komen in deze talen.

      De functionele programmeertalen zijn ook erg schaalbaar, zo zijn bepaalde
      algoritmes in functionele programmeertaal vaak minder regels code dan in
      een imperatieve taal, doordat functionele talen vaak een hogere
      abstractie hanteren, denk hierbij aan het gebruik van \textit{'hogere
      graads functies'}. Dit zorgt voor een duidelijker en beter herbruikbaar
      systeem, waar elk stuk code een eigen, gescheiden verantwoordelijkheid
      heeft, dit heet modulariteit.
    }

    \AppendixItem{Algemene nadelen functioneel programmeren}{

      Functioneel programmeren kent zo echter ook zijn programmeertalen zijn er
      nadelen wat betreft het gebruik van functioneel programmeren. Zo zijn
      vrijwel vaak functionele programmeertalen langzamer ten opzichte van
      imperatieve programmeertalen, aangezien deze talen focussen op
      abstractie, waardoor de programmeur minder mogelijkheden heeft om direct
      het onderliggende geheugengebruik te controleren.

      Ook maken de meeste functionele programmeertalen gebruik van static type
      checking. Wanneer een verkeerd type variabele wordt gebruikt, zal het
      programma niet werken.

      Waar in andere programmeerparadigma's veel gebruik kan worden gemaakt van
      libraries, is dit bij functioneel programmeren niet/minder vaak het
      geval, op een paar libraries na.

      Wat bij programmeren tot \'e\'en van de meest belangrijke zaken behoort,
      is portability. Dit is niet het geval bij programma's geschreven in een
      functionele programmeertaal. Omdat het omzetten hiervan erg lastig is.

      Ook het gebruik van programma's gebouwd met functionele programmeertalen,
      kunnen nadelig zijn. Omdat er allerlei extra bestanden worden bijgeleverd
      om het programma te kunnen gebruiken, kost dit ook meer qua werkgeheugen,
      wat betekent dat daar ook rekening mee moet worden gehouden, met het
      kiezen van functionele talen over object geori\"enteerd.
    }

    \AppendixItem{Conclusie}{
    }

    \clearpage

  \AppendixSection{Deelopdracht 4}

  \AppendixSubSection{Persoonlijke evaluatie Sjors Sparrebooom}

    \AppendixItem{Beoordeling eigen functioneren}{
      Uitmuntend, ik ben erg betrokken geweest bij de opdracht en heb veel
      mensen het artikel laten nalezen. Daarnaast vind ik het een interessant
      onderzoeksgebied, wat hielp bij het lezen van de bronnen en heb mijzelf
      dus erg verdiept.
    }

    \AppendixItem{Belangrijkste zaken ontwikkeling}{
      Het schrijven van een goed rapport/onderzoek/factchecker en het
      structuren en aanpakken hiervan.

      Veel geleerd van het volgende
      \href{https://www.youtube.com/watch?v=VK51E3gHENc}{artikel}: \textit{'How
      to write a great research paper'}.
    }

    \AppendixItem{Beheersing}{
      Ik vind persoonlijk dat ik alle vaardigheden benodigd voor dit vak
      beheers, dit blijkt dan ook zeker uit het eindresultaat.
    }

    \AppendixItem{Welk cijfer voor de opdracht}{
      Een 9! Een 10 vertelt namelijk dat er geen mogelijkheid is voor
      verbetering, maar dat is er altijd, maar dat neemt niet weg dat ik zeer
      trots ben op het artikel.

      Zo vind ik het artikel HBO waardig, het heeft een sterke inhoud, goede
      bronnen en een goede structuur/opbouw. Ik heb er dan ook veel tijd en
      ingestoken en het eindresultaat mag er van mij dan ook wezen.
    }

    \AppendixItem{Beoordeling teamgenoot}{
      Ik hoop dat alles goed gaat met Johan, want ik heb de laatste weken
      namelijk niets van hem gehoord en maak mij dus ook een beetje zorgen.

      Johan geen pro actieve houding helaas en de benaderings pogingen die ik
      heb gedaan kreeg ik geen of nauwelijks antwoord op.

      Dus over de verdeling kan ik het volgende zeggen:
      De verdeling en werkinspanning ziet u in~\cref{tab:work}.
      \begin{table}[htpb]
        \centering
        \caption{Verdeling}
        \label{tab:work}
          \begin{tabular}{|l|l|}
            \hline
            Sjors & 90\% \\
            \hline
            Johan & 10\% \\
            \hline
          \end{tabular}
      \end{table}
    }

    \clearpage

    \AppendixItem{Oordeel opdracht}{
      Zelf vind ik het een leuke opdracht, het schrijven van een \textbf{GOED}
      research rapport is niet vervelend. Een interessant onderwerp, en een
      goede aanleiding kunnen zeker helpen met het schrijven van een
      interessant artikel.

      Echter was de manier zoals school je wil voorbereiden op je scriptie,
      door middel van een zogeheten \textit{'factchecker'} een minder goede
      bijdragen aan de algehele waarde van deze cursus.

      Ook kwamen de deelopdrachten kinderachtig over op mij. Aangezien ze
      compleet geen meerwaarde hadden voor het schrijven van het artikel
      (factchecker). Naast de vreselijke deelopdrachten zaten we ook nog met
      oudbollige youtube links, die studenten moesten helpen met het schrijven
      van een goed artikel.

      Als alternatief voor de oudbollige links raadt ik de volgende
      \href{https://www.youtube.com/watch?v=VK51E3gHENc}{link} aan van
      professor Simon Peyton Jones.

     Honours \& awards van de spreker in de video: Simon Peyton Jones.\\\\

    \textbf{Fellowships}

     \begin{itemize}
       \item Fellow of the Royal Society (2016)
       \item Distinguished Fellow of the BCS (2017)
       \item Distinguished Fellow of the BCS (2017)
     \end{itemize}

    \textbf{Received the following honorary degrees:}

    \begin{itemize}
      \item Honorary DSc from the University of Glasgow (2013); Muffy Calderâs oration
      \item Honorary DEd from the University of Bath (2017); Chris Buddâs oration; video
      \item Honorary DSc from the University of Kent, Canterbury (2017)
      \item Honorary DSc from the Queen Mary University of London (2017)
    \end{itemize}
    \textbf{Awards}

    \begin{itemize}
      \item The 2016 ACM SIGPLAN Programming Languages Achievement Award
      \item The 2016 ACM SIGPLAN Most Influential ICFP Paper Award (shared with Dimitrios Vytiniotis, Stephanie Weirich, and Geoffrey Washburn)
      \item The 2015 ACM SIGPLAN Most Influential ICFP Paper Award (shared with Manuel M. T. Chakravarty and Gabriele Keller)
      \item The 2014 ACM SIGPLAN Distinguished Service Award
      \item The 2014 ACM SIGPLAN Most Influential ICFP Paper Award (shared with Ralf L\"ammel)
      \item The 2011 ACM SIGPLAN Programming Languages Software Award (shared with Simon Marlow)
      \item The 2003 ACM SIGPLAN Most Influential POPL Paper Award (shared with Philip Wadler)
    \end{itemize}
  }



\end{appendices}

%------------------------------------------------------------------------------

\end{document}
