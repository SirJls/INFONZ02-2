%------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%------------------------------------------------------------------------------

\documentclass[twoside,twocolumn]{article}

\usepackage[dutch]{babel} % Language hyphenation and typographical rules

\usepackage[
    backend=biber,
    style=numeric-comp,
  ]{biblatex}
\addbibresource{main.bib}

\usepackage{csquotes}

\usepackage{listings}
\lstdefinelanguage{Lambda}{%
  morekeywords={%
    if,then,else,fix % keywords go here
  },%
  morekeywords={[2]int,string},   % types go here
  otherkeywords={:}, % operators go here
  literate={% replace strings with symbols
    {->}{{$\to$}}{2}
    {lambda}{{$\lambda$}}{1}
  },
  basicstyle={\sffamily},
  keywordstyle={\bfseries},
  keywordstyle={[2]\itshape}, % style for types
  keepspaces,
  mathescape % optional
}[keywords,comments,strings]%
\lstdefinestyle{CStyle}{language=C,frame=t,basicstyle=\scriptsize}
\lstdefinestyle{HsStyle}{language=Haskell,frame=b,basicstyle=\scriptsize}
\lstdefinestyle{LambdaStyle}{
  language=Lambda,
  frame=bt,
  basicstyle=\scriptsize,
  numberstyle=\tiny,
  numbersep=0pt,
}

\lstset{
  language=Lambda,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  postbreak=\mbox{\textcolor{RoyalRed}{$\drsh$}\space},
  numbers
}


\usepackage{blindtext} % Package to generate dummy text throughout this template

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{amsmath}
\usepackage{mathabx}


\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{subfig}

\usepackage{algorithmicx} % We need to write some pseudocode
\usepackage{algorithm, algpseudocode} % We need floating algorithms

\algdef{SE}[VARIABLES]{Variables}{EndVariables}
   {\algorithmicvariables}
   {\algorithmicend\ \algorithmicvariables}
\algnewcommand{\algorithmicvariables}{\textbf{Shared Variable}}

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{multicol} % We need multicolumn support for appendix

\usepackage{graphicx} % Graphics

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{Het functionele paradigma is de toekomst} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

% \addto\captionsdutch{\renewcommand{\appendixname}{Bijlage}} % changes 'BÃ¿lage' to 'Bijlage' for the bookmarks

\usepackage{xcolor}
\definecolor{RoyalBlue}{RGB}{0,35,102}
\definecolor{RoyalRed}{RGB}{157,16,45}
\definecolor{Orange}{RGB}{255,127,0}

\usepackage[
  pdfusetitle
    ,colorlinks=true
    ,allcolors=RoyalBlue
    ,pdfborder={0 0 0}
    ,unicode=true
  ]{hyperref}

\usepackage[toc,title]{appendix}
\usepackage[dutch]{cleveref}

%------------------------------------------------------------------------------
%	FIGURES
%------------------------------------------------------------------------------
\newcommand{\igopt}[2]{\includegraphics[#1]{#2}} %%! options, filename

\newcommand{\ig}[2]{\igopt{width=#1\columnwidth}{#2}} %%! width in units of textwidth, filename

\newcommand{\figopt}[4]{ %%! width, filename, caption, placement (h, t, ht)
  \begin{figure}[#4]
    \centering
        \ig{#1}{#2}
        \caption{#3}
        \label{fig:#2}
  \end{figure}
}

\newcommand{\fig}[3]{ %%! width, filename, caption
  \figopt{#1}{#2}{#3}{ht}
}

\newcommand{\doublefigopt}[8]{ %%! w1, f1, c1, w2, f2, c2, main caption, placement
  \begin{figure}[#8]
    \centering
        \subfloat[#3]{
          \ig{#1}{#2}
            \label{fig:#2}
          }
        \subfloat[#6]{
          \ig{#4}{#5}
            \label{fig:#5}
          }
        \caption{#7}
        \label{fig:#2_#5}
  \end{figure}
}

\newcommand{\doublefig}[7]{\doublefigopt{#1}{#2}{#3}{#4}{#5}{#6}{#7}{ht}} %%! w1, f1, c1, w2, f2, c2, main caption

%------------------------------------------------------------------------------
%	APPEDIX ENTRIES
%------------------------------------------------------------------------------

% Headings within sections.
% Parameter 1: Section name.
\newcommand{\AppendixSection}[1]{
  {
    \begin{flushleft}
      \section{\Large#1}}
      \label{app:#1}
    \end{flushleft}
  }

  % AppendixItem to use within sections.
  % Parameter 1: Item title/name.
  % Parameter 2: Context.
\newcommand{\AppendixItem}[2]{
  \textbf{\color{RoyalRed}
  \begin{flushleft}
    #1:
  \end{flushleft}
  }\par\newline #2}


%------------------------------------------------------------------------------
%	TITLE SECTION
%------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Het functionele paradigma is de toekomst.} % Article title
\author{%
  \textsc{Sjors Sparreboom} \\[1ex] % Your name
\normalsize Hogeschool Rotterdam \\ % Your institution
\normalsize \href{mailto:0890040@hr.nl}{0890040@hr.nl} \\[2ex] % Your email address
%\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
\textsc{Johan Bos} \\[1ex] % Second author's name
\normalsize Hogeschool Rotterdam \\ % Second author's institution
\normalsize \href{mailto:0878090@hr.nl}{0878090@hr.nl} % Second author's email address
}
\date{\today} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
  \begin{abstract}
    \noindent
    Met de komst van het internet, big data en de toenemende capaciteit van
    computers is er vernieuwde interesse in de functionele programmeertalen.
    Dit rapport onderzoekt samen met de lezer de voor en nadelen bij de
    stelling ``Het functionele paradigma is de toekomst.'' Dit gebeurt op basis
    van een literatuuronderzoek naar de relaties en verschillen van de
    heersende programmeerparadigma's. Het onderzoek beperkt zich tot het
    imperatieve en functionele paradigma. Om het functionele paradigma en zijn
    plaats binnen de informatica beter te kunnen begrijpen is er binnen dit
    onderzoek van een minimale kennisgeving van de heersende
    programmeerparadigma's uitgegaan. Ook is kennis van programmeren wenselijk,
    maar het onderzoek kan ook prima zonder deze kennis worden gevolgd.
  \end{abstract}
}

%------------------------------------------------------------------------------

\begin{document}
\nocite{*}

% Print the title
\maketitle

%------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%------------------------------------------------------------------------------

\section{Inleiding}
\label{sec:1}
\lettrine[nindent=0em,lines=3]{D}it document is een poging om de gemeenschap te
overtuigen van de significantie van functioneel programmeren alsook te
informeren wat de voordelen en nadelen zijn van dit paradigma.

Functioneel programmeren dankt zijn naam aan zijn fundamentele werking,
namelijk de toepassing van functies op argumenten. Dit beschrijft wat
het inhoudt, maar wat is nu eigenlijk een functioneel programma? Een
mooie beschrijving van een functioneel programma is die van~\textcite{src1}:
\enquote{Een functioneel programma is een functie waar de gegeven input voor
dit programma wordt behandeld als argument van een functie, welk vervolgens het
resultaat hiervan teruggeeft als output}.

Het functioneel programmeren is niet nieuw en bestaat al sinds de jaren 40. De
fundamentele werking van deze stijl van programmeren is gebaseerd op
het \textit{lambda calculus}\cite{src2,src3}. Typerend voor deze stijl is dat
functies opgebouwd zijn uit andere functies. Een mooi voorbeeld is de hoofd
functie (het programma zelf), deze is opgebouwd uit functies, welke op hun
beurt ook weer opgebouwd zijn uit functies; dit heet modulariteit een concept
dat wordt behandeld in~\cref{subsec:3-2}. Ook zijn functionele programma's
inherent parallel~\cite{src4,src12} en zijn er geen~\textit{assignments},
waardoor variabelen met een waarde niet meer kunnen veranderen
(zie~~\cref{subsec:3-1}).

In de rest van dit document zal er worden gediscussieerd over de voor- en
nadelen van deze vorm van programmeren en zal er in~\cref{sec:5} af worden
gesloten met een conclusie op de stelling~\textit{``Het functionele paradigma
is de toekomst``}.

%------------------------------------------------------------------------------

\section{Middenstuk}
\label{sec:2}

In dit middenstuk wordt er eerst korte uitleg gegeven over imperatief
programmeren. De ge\"informeerde lezer kan ervoor kiezen deze paragraaf over te
slaan, maar moet onthouden dat kennis van imperatief programmeren benodigd is
in de volgende paragrafen.

Opvolgend zal er worden gekeken naar de voordelen en nadelen van de
stelling~\textit{``Het functioneel programmeren is de toekomst''}.

%------------------------------------------------------------------------------

\subsection{Imperatief programmeren}
\label{subsec:2-1}

De term imperatief programmeren is een letterlijke beschrijving van het gedrag
dat deze programma's vertonen, namelijk het sequentieel uitvoeren van een lijst
van instructies. Echter is het vanuit deze context niet duidelijk wat een
imperatief programma is. Een duidelijke beschrijving van imperatief
programmeren wordt gegeven door~\textcite[hfdst.~3]{src6} en luidt als volgt:

\begin{quote}
  Imperatief programmeren staat in tegenstelling tot functioneel programmeren
  dichtbij de machine representatie. Het introduceert een \textit{memory state}
  die door acties van het programma kunnen worden gemodificeerd. Deze acties
  worden ook wel \textit{instructies} genoemd en een imperatief programma is
  dan ook een lijst van deze instructies.
\end{quote}

Kort samengevat heeft een imperatief programma net als een assembleer programma
een memory state concept, dat het mogelijk maakt de staat van een programma aan
te passen. Input-output acties zijn in imperatieve programma's dan ook
modificaties van het geheugen.

%------------------------------------------------------------------------------

\section{Algemene voordelen functioneel programmeren}
\label{sec:3}

Uit het onderzoek van~\textcites{src7}{src8} blijkt dat de imperatieve stijl
hedendaags nog steeds de populairste vorm van programmeren is. Wat echter opvalt
is dat er enkele functionele talen in deze resultaten (Erlang, Scala, F#,
Haskell, Clojure) staan, en dit is niet toevallig.

In~\cref{subsec:3-1} en~\cref{subsec:3-2} wordt de aanleiding van deze nieuwe
interesse in functionele talen onderzocht.

\subsection{Parallel en Gedistribueerd programmeren}
\label{subsec:3-1}

Sinds de uitvinding van het internet en \textit{big data} is er buiten de
academische wereld nieuwe interesse ontstaan in de functionele talen. Zoals
beschreven door~\textcite{src10} zijn er met komst van big data nieuwe manieren
van dataverwerking nodig, aangezien de traditionele manieren niet langer
toereikend zijn. Deze nieuwe manieren van dataverwerking baseren zich op twee
vormen van computatie die door de goedkopere en verbeterde hardware componenten
en de komst van de \textit{multi-core processor} een geheel nieuw domein aan
mogelijkheden openen; namelijk \textit{parallel} en \textit{gedistrubeerd}
computeren~\cite{src10,src11}.

Voordat wordt onderozoht waarom fuctionele talen zo geschikt zijn voor parallel
en gedistrubeerd programmeren, zal er eerst gekeken moeten worden waarom de
imperatieve stijl van programmeren niet volstaat voor deze vorm van computatie.

In~\cref{subsec:2-1} wordt al gesproken over het gebruik van een memory state in
deze imperatieve programma's. Het is nu juist het gebruik van deze muteerbare
memory state die het parallel en gedistribueerd computeren compliceert. Doordat
imperatieve programma's inherent sequentieel zijn, is de volgorde van executie
in een parallel of gedistrubeerd programma belangrijk. Wijkt de volgorde van
executie echter af, dan kan er een \textit{race conditie} ontstaan.

Race condities zijn \'e\'en van de grootste oorzaken van bugs in een parallel
en gedistrubeerd programma en ontstaan wanneer twee processen allebei
tegelijkertijd naar een stukje geheugen willen schrijven~\cite{src1}.

Het voorkomen van race race condities is niet gemakkelijk, zeker omdat in een
moderne multi-core CPU, deze CPU'S niet dezelfde \textit{througput} hebben.
In~\citetitle{src14} vertellen~\citeauthor{src14} dat in imperatieve
programma's een concept genaamd \textit{locks} (ook wel \textit{mutexes}
genoemd) is ge\"introduceerd om deze race condities tegen te gaan. Een werkende
oplossing, die echter zelf voor een nieuw probleem zorgt, namelijk
\textit{deadlock}.

Deadlock is een toestand waar elke proces wacht op een ander proces, wat
betekent dat een programma niet verder zal gaan en beland is in een oneindige
cyclus. Een programma die lijdt aan een situatie waarin er ongewenst mutaties
worden gedaan op data en een hierdoor de werking in 

Deze toestand is mogelijk  door de muteerbare data van een imperatief
programma mogelijk is. Programma's met een dergelijke situatie passen dus
buiten hun scope data en hebben een \textit{side-effect}.

Het is dus wenselijk side-effects te voorkomen in een programma, maar hoe is
dit mogelijk? Volgens~\citeauthor{src14}~\cite{src14,src15} ligt de oplossing
in het gebruik van een functionele programmeertaal. Functionele
programmeertalen hebben geen van de bovengenoemde problemen. Zo zijn ze
inherent parallel en is data in deze programma's niet muteerbaar, omdat er geen
\textit{assigment} declaratie is. Dit elimineert een belangrijke bron van bugs,
zoals de deadlock en race conditie en maakt de executie volgorde van deze
programma's irrelevant.

\subsection{Schaalbaar en Modulair}
\label{subsec:3-2}

In~\cref{sec:1} is al kort aangehaald dat functionele programma's modulair
zijn doordat functies opgebouwd zijn uit andere functies, een concept genaamd
\textit{currying}~\cite[hfdst.~5]{src16}.

Het voordeel van currying is door deze manier van functie applicatie, functies
gedeeltelijk kunnen worden toepast~\cite{src1}. Hierdoor kunnen er nieuwe
functies van oude afgeleid worden en maakt een functionele taal erg schaalbaar.

Door deze schaalbaarheid is het gemakkelijker modulair software te schrijven.
Deze manier van software maken wordt volgens vele al jaren lang beschouwt als
\'e\'n van de belangrijkste punten in het construeren van herbruikbare en
onderhoudbare software~\cite{src17}. Zo spreken ook~\textcite{src18} hun
voorkeur uit over de modulaire aanpak van het ontwerpen van software, omdat er
hierdoor toekomstige legacy problemen kunnen worden voorkomen; hierover meer
in~\cref{subsec:4-2}.

Modulair programmeren is dus een pre, maar wat is een module nu precies?
\textcite[hdfst.~6]{src16} beschrijft een module als: \enquote{Een module een
collectie van gerelateerde functies, types en typeclasses}. Wat types en
typeclasses zijn is in dit document niet relevant. Wat wel relevant is dat door
de modulariteit en schaalbaarheid van functionele programma's veel algoritmes
vaak korter zijn dan in een imperatief programma. Zo zijn hieronder twee
versies van quicksort; een imperatieve versie in C en een functionele
versie in Haskell zichtbaar.

\begin{lstlisting}[style=CStyle]
  void Sort(int input[],int left,int right)
  {
    int L = left;
    int R = right;
    int M = input[(left + right) / 2];

    do
    {
      while(input[L] < M)
      {
        L++;
      }
      while(M < input[R])
      {
       R--;
      }

      if(L <= R)
      {
        int inputLeft = input[L];
        input[L] = input[R];
        input[R] = inputLeft ;
        L++;
        R--;
      }
   } while(L < R);

    if(left < R)
    {
      Sort(input, left, R);
    }
    if(L < right)
    {
      Sort(input, L, right);
    }
  }

  void QuickSort(int input[], int length)
  {
    Sort(input, 0, length - 1);
  }
}
\end{lstlisting}

\begin{lstlisting}[style=HsStyle]
quicksort :: Ord a => [a] -> [a]
quicksort []     = []
quicksort (p:xs) =
   (quicksort lesser) ++ [p] ++ (quicksort greater)
    where
        lesser  = filter (< p) xs
        greater = filter (>= p) xs
\end{lstlisting}

Wat uit het bovengenoemde voorbeeld opvalt is dat de functionele versie veel
duidelijker en expressiever is, dan de imperatieve versie. In de imperatieve
versie is de bedoeling van het programma niet gelijk duidelijk en moet er
sequentieel over het programma worden gelopen om te begrijpen wat de bedoeling
ervan is.

%------------------------------------------------------------------------------

\section{Algemene nadelen functioneel programmeren}
\label{sec:4}

Dat de functionele stijl van programmeren tegenwoording steeds vaker wordt
overwogen, is zichtbaar in~\cref{sec:3}. Er zijn echter ook gebieden en
problemen die zich niet schikken voor een functionele aanpak van het probleem.
In~\cref{subsec:4-1} en~\cref{subsec:4-2} wordt er dan ook onderzocht waar deze
desinteresse vandaan komt.

\subsection{Portabiliteit en Beschikaarheid}
\label{subsec:4-1}

Beschikbaarheid en portabiliteit van functionele talen op verschillende
architecturen en platformen is een grote reden waarom het soms beter is te
besluiten tegen het gebruik van deze talen en te kiezen voor een imperatieve
tegenhanger. Er zijn dan ook genoeg projecten waarvan de ontwikkelaars liever
het project hadden gebouwd in een functionele taal, maar vervolgens toch
besloten te kiezen voor C of C++. E\'en van deze projecten is de taal voor de
PRL database. Volgens~\textcite{src19} besloten onderzoekers van Lucent om
deze taal te bouwen in SML, om ultimatum te kiezen C++, omdat SML niet
beschikbaar was op het Amdahl mainframe.

Dezelfde problemen zijn te analyseren voor
\textit{embedded systems}~\cite{src20}. Bij het programmeren van deze systemen
moet er rekening worden gehouden dat de architectuur van deze veel kan
verschillen van de algemene computer en dat er weinig intern geheugen
beschikbaar is~\cite{src21,src22}. Om toch goede programma's te kunnen
schrijven voor deze systemen is het dus noodzakelijk voor de programmeur om
direct het geheugen te kunnen controleren.

Functionele programma's alloceren echter in korte tijd veel geheugen. Dit is
geen probleem op systemen met genoeg geheugen, maar wordt een probleem in
een embedded omgeving. Om ervoor te zorgen dat voldoende geheugen beschikbaar
is, worden zogenaamde cells na gebruik vrijgegeven door een \textit{garbage
collector}~\cite{src23}. Deze afhankelijkheid van garbage collectie zorgt ervoor dat er
beperkte controle is over het geheugen. Dit gebrek over controle van het
geheugen maakt de meeste moderne functionele talen niet geschikt voor embedded
systemen, zeker de systemen met weinig geheugen of harde \textit{real-time}
beperkingen~\cite{src24}.

\subsection{Legacy code en Infrastructuur}
\label{subsec:4-2}

Er is veel commerci\"ele software in de omloop dat is gedateerd en kan
profiteren van de voordelen van functioneel programmeren. Om deze voordelen te
benutten moet de huidige infrastructuur van deze systemen worden veranderd, wat
in de praktijk een nogal lastig en gevoelig onderwerp blijkt te zijn. In de
systemen is namelijk hevig ge\"investeerd en de werking ervan is vaak verworven
met de gebruiksdoeleinde~\cite{src18,src25}.

Vervanging is dus lastig, zeker als er nagegaan wordt dat na decennia lang
schrijven van software, systemen vaak samengesteld zijn uit componenten. Veel
van deze componenten zijn geschreven in een imperatieve programmeertaal zoals C
of C++. Hierdoor is een \textit{foreign function interface} met C of C++ vaak
noodzakelijk zijn om de achterwaartse comptabiliteit te garanderen\cite{src19}.
Echter door de isolationistische natuur van functionele talen zijn deze foreign
function interfaces moeilijk implementeerbaar en word er vaak nog steeds
gekozen voor makkelijk koppelbare imperatieve programmeertaal.

\section{Conclusie}
\label{sec:5}

In dit document is er gediscussieerd over de voordelen en nadelen van het
functioneel programmeren. In~\cref{sec:3} wordt duidelijk dat met de komst van
het internet en de ontwikkelingen op hardware gebied er nieuwe interesse is
voor functioneel programmeren.

De schaalbaarheid, modulariteit, niet muteerbare datastructuren en het inherent
vermogen om parallel expressies te evalueren maakt functioneel programmeren een
programmeertsstijl die zeer geschikt is om software te schrijven voor de 21$^e$
eeuw.

Het is echter misschien iets te vroeg om te stellen dat de functionele stijl
van programmeren de toekomst is. Zo is er nog steeds geen functionele opmars
zichtbaar in de embedded systems hoek en worden legacy problemen in grote
commerci\"ele software systemen nog altijd imperatief opgelost.

Er is een glansrijke toekomst voor de functionele stijl van programmer, maar
vooralsnog moet er goed gekeken worden naar de probleemstelling en het doel
voor er paradigmatisch besluit kan worden genomen.

%------------------------------------------------------------------------------
%	REFERENCE LIST
%------------------------------------------------------------------------------

\printbibliography

\clearpage
\onecolumn

%------------------------------------------------------------------------------
%	APPENDIX
%------------------------------------------------------------------------------

\begin{appendices}

  \AppendixSection{Terminologie}

  \AppendixItem{Assignment}{
    Een \textit{assignment} stelt de waarde in die is opgeslagen in de
    opslaglocatie dat wordt aangeduid met een variabelenaam.
  }


  \AppendixItem{Big Data}{
    Data sets die zo enorm en complex zijn dat traditionele
    dataverwerkingssoftware niet langer toereikend zijn.
  }

  \AppendixItem{Deadlock}{
    \textit{Deadlock}, zoals te zien in~\cref{fig:./fig/deadlock.png} is een
    toestand waarin elk proces wacht op een ander proces. Deze toestand kan
    voorkomen wanneer de locks worden verkregen in de verkeerde volgorde.
    \fig{0.3}{./fig/deadlock.png}{Deadlock (source:
    wikipedia.org/wiki/Deadlock)}
  }

  \AppendixItem{Foreign function interface}{
    Een \textit{foreign function interface} (FFI) is een mechanisme waarmee een
    programma dat in een programmeertaal is geschreven, routines kan noemen of
    gebruik kan maken van services die in een andere taal zijn geschreven.
  }

  \AppendixItem{Gedistribueerde computatie}{
    Een \textit{gedistribueerd computatie} is een computatie waar een enkele
    taak wordt opgesplitst in meerdere subtaken. Deze subtaken worden
    vervolgens gedistribueerd over verschillende nodes in een netwerk en
    onafhankelijk berekent. Als al deze computaties gedaan zijn zullen deze
    onafhankelijke berekeningen worden samengevoegd tot \'e\'en resultaat,
    zoals te zien in~\cref{fig:./fig/distributed_process.png}.
    \fig{0.7}{./fig/distributed_process.png}{Gedistribueerd proces}
  }

  \newpage

  \AppendixItem{Lock/Mutex}{
    \textit{Lock}, zoals te zien in~\cref{fig:./fig/lock.png} is een mechanisme
    om het benaderen van een bron in een omgeving te beperken.
    \fig{0.3}{./fig/lock.png}{Lock/Mutex}
  }

  \AppendixItem{Memory leak}{
    Een \textit{Memory leak} betekent dat een programma meer geheugen toewijst
    dan nodig voor de executie. Dit kan over tijd erg oplopen aangezien dit
    niet gebruikte geheugen nooit opnieuw toegewezen kan worden, zonder het
    wordt gedealloceerd.
  }

  \AppendixItem{Multi-core processor}{
    \textit{Multi-core processoren}, bestaan uit verschillende processoren en
    gedeeld geheugen, zie~\cref{fig:./fig/mutlicore.png}. Deze processoren zijn
    sneller en hebben een lager energieverbruik dan de single-core processor,
    zie~\cref{fig:./fig/singlecore.png}, echter is het programmeren voor deze
    architectuur een stuk lastiger.
    \fig{0.3}{./fig/mutlicore.png}{Multi-core processor}
  }

  \AppendixItem{Memory state}{
    \textit{Memory state} alle opgeslagen ingegeven waardes van een programma
    als variabelen of constanten. Bij het analyseren van de status van dit
    programma kunnen programmeurs deze opgeslagen ingegeven waardes bekijken.
  }

  \AppendixItem{Parallelle computatie}{
    Een \textit{parallelle computatie} is een vorm van computatie waarin
    meerdere calculaties simultaan kunnen worden uitgevoerd. Deze vorm van
    executie is sinds de komst van de multi-core processor,
    zie~\cref{fig:./fig/mutlicore.png} het dominante paradigma in computer
    architectuur.

    Een parallelle executie van een proces wordt gedaan door gebruik te maken
    van threads, zie~\cref{fig:./fig/thread.png}.
    In~\cref{fig:./fig/parallel_process_cores.png} is een parallelle
    executie op een multi-core processor zichtbaar
    (\cref{fig:./fig/mutlicore.png}).

    Wat opvalt zijn de extra kernen van deze architectuur, die een
    single-core processor, zoals te zien in~\cref{fig:./fig/singlecore.png}
    niet heeft. Als deze verschillende kernen zinnig werk tegelijkertijd doen
    kan dit het gehele proces versnellen.
    \fig{0.3}{./fig/parallel_process_cores.png}{Parall proces}
  }

  \newpage

  \AppendixItem{Process \& Thread}{
    Een \textit{thread} is de kleinste sequentie van een programma dat
    onafhankelijk kan opereren. Hoe een proces en thread opereren hangt af van
    de implementatie van het operatie systeem. De meeste voorkomende
    implementatie is dat een thread een onderdeel is van het proces, zoals te
    zien in~\cref{fig:./fig/thread.png}.
    \fig{0.2}{./fig/thread.png}{Thread}
  }

  \AppendixItem{Race conditie}{
    Twee processen P1 en P2, kunnen beide schrijven naar de variabel
    $tmp$. De intentie van de programmeur is dat zowel proces P1 als P2
    $tmp$ van een waarde voorziet, deze vervolgens gelijk te gebruiken en een
    uiteindelijke waarde voor $y$ en $z$ te presenteren. De executie van
    algoritme~\cref{algo:algo1} levert de volgende waardes voor $y$ en $z$:
    \begin{gather*}
      y = 24, z = 2055
    \end{gather}

    Echter doordat de processen op verschillende snelheden kunnen draaien, doet
    zich een situatie voor, zoals te zien in algoritme~\cref{algo:algo2} waar
    de volgorde van executie niet wordt uitgevoerd zoals de programmeur had
    bedoeld. De executie van levert de volgende waardes voor $y$ en $z$:
    \begin{gather*}
      y = 4096, z = 2055
    \end{gather}
    Zoals te zien is dit niet de juiste waarde voor $y$. Deze situatie wordt
    ook wel een race conditie genoemd in de informatica.

    \begin{multicols}{2}
      \begin{algorithm}[H]
        \caption{Programmeurs intentie}
        \label{algo:algo1}
        \begin{algorithmic}
          \Variables
          \State $tmp$
          \EndVariables
          \begin{multicols}{2}
            \Procedure{P1}{}
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \State $tmp = 12 $
            \State $y = 2 \times tmp$
            \EndProcedure
            \columnbreak
            \Procedure{P2}{}
            \State $tmp = 2048$
            \State $z = tmp + 7$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \EndProcedure
          \end{multicols}
        \end{algorithmic}
      \end{algorithm}
      \columnbreak
      \begin{algorithm}[H]
        \caption{Race conditie}
        \label{algo:algo2}
        \begin{algorithmic}
          \Variables
          \State $tmp$
          \EndVariables
          \begin{multicols}{2}
            \Procedure{P1}{}
            \State $tmp = 12 $
            \State $\mathbf{.}$
            \State $y = 2 \times tmp$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \EndProcedure
            \columbreak
            \Procedure{P2}{}
            \State $\mathbf{.}$
            \State $tmp = 2048$
            \State $\mathbf{.}$
            \State $z = tmp + 7$
            \State $\mathbf{.}$
            \EndProcedure
          \end{multicols}
        \end{algorithmic}
      \end{algorithm}
    \end{multicols}
  }

  \AppendixItem{Real-time proces}{
    Een \textit{real-time proces} is een proces waarin een programma het
    resultaat moet garanderen binnen een bepaalde tijd.
  }

  \AppendixItem{Side-effect}{
    Binnen de informatica heeft een programma, functie of expressie een
    \textit{side-effect} wanneer het een waarde buiten zijn scope aanpast of
    een interactie heeft met zijn aanroep functies of de rest van het programma
    zonder een waarde te retourneren.
  }


  \AppendixItem{Single-core Processor}{
    \textit{Single-core processoren} hebben maar 1 processor direct verbonden
    aan het geheugen. Deze processoren zijn gemakkelijk te programmeren, maar
    hebben echter een lagere hoog energieverbruik en een lage prestatie, in
    tegenstelling tot de multi-core processor,
    zie~\cref{fig:./fig/mutlicore.png}.
    \fig{0.3}{./fig/singlecore.png}{Single-core processor}
  }

  \AppendixItem{Throughput}{
    \textit{Throughput} is de maximale snelheid waarop \textit{iets} kan worden
    verwerkt.
  }

\end{appendices}

%------------------------------------------------------------------------------

\end{document}
