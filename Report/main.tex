%------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%------------------------------------------------------------------------------

\documentclass[twoside,twocolumn]{article}

\usepackage{blindtext} % Package to generate dummy text throughout this template

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{amsmath}

\usepackage[dutch]{babel} % Language hyphenation and typographical rules
\usepackage[titletoc,title]{appendix}

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{algorithmicx} % We need to write some pseudocode
\usepackage{algorithm, algpseudocode} % We need floating algorithms

\algdef{SE}[VARIABLES]{Variables}{EndVariables}
   {\algorithmicvariables}
   {\algorithmicend\ \algorithmicvariables}
\algnewcommand{\algorithmicvariables}{\textbf{Shared Variable}}

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{multicol} % We need multicolumn support for appendix

\usepackage{graphicx} % Graphics

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{Het functionele paradigma is de toekomst} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\addto\captionsdutch{\renewcommand{\appendixname}{Bijlage}} % changes 'BÃ¿lage' to 'Bijlage' for the bookmarks

\usepackage{xcolor}
\definecolor{RoyalBlue}{RGB}{0,35,102}
\definecolor{RoyalRed}{RGB}{157,16, 45}

\usepackage[
  pdfusetitle
    ,colorlinks=true
    ,allcolors=RoyalBlue
    ,pdfborder={0 0 0}
    ,unicode=true
  ]{hyperref}

%------------------------------------------------------------------------------
%	FIGURES
%------------------------------------------------------------------------------
\newcommand{\igopt}[2]{\includegraphics[#1]{#2}} %%! options, filename

\newcommand{\ig}[2]{\igopt{width=#1\columnwidth}{#2}} %%! width in units of textwidth, filename

\newcommand{\figopt}[4]{ %%! width, filename, caption, placement (h, t, ht)
    \begin{figure}[#4]
        \centering
        \ig{#1}{#2}
        \caption{#3}
        \label{fig:#2}
    \end{figure}
}

\newcommand{\fig}[3]{ %%! width, filename, caption
    \figopt{#1}{#2}{#3}{ht}
}

\newcommand{\doublefigopt}[8]{ %%! w1, f1, c1, w2, f2, c2, main caption, placement
    \begin{figure}[#8]
        \centering
        \subfloat[#3]{
            \ig{#1}{#2}
            \label{fig:#2}
        }
        \subfloat[#6]{
            \ig{#4}{#5}
            \label{fig:#5}
        }
        \caption{#7}
        \label{fig:#2_#5}
    \end{figure}
}

%------------------------------------------------------------------------------
%	APPEDIX ENTRIES
%------------------------------------------------------------------------------

% Headings within sections.
% Parameter 1: Section name.
\newcommand{\AppendixSection}[1]{
  {
    \begin{flushleft}
      \Large\textbf{#1}}
    \end{flushleft}
  }

% AppendixItem to use within sections.
% Parameter 1: Item title/name.
% Parameter 2: Context.
\newcommand{\AppendixItem}[2]{
  \textbf{\color{RoyalRed}
  \begin{flushleft}
    #1:
  \end{flushleft}
  }\par\newline #2}


%------------------------------------------------------------------------------
%	TITLE SECTION
%------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Het functionele paradigma is de toekomst.} % Article title
\author{%
  \textsc{Sjors Sparreboom} \\[1ex] % Your name
\normalsize Hogeschool Rotterdam \\ % Your institution
\normalsize \href{mailto:0890040@hr.nl}{0890040@hr.nl} \\[2ex] % Your email address
%\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
\textsc{Johan Bos} \\[1ex] % Second author's name
\normalsize Hogeschool Rotterdam \\ % Second author's institution
\normalsize \href{mailto:0878090@hr.nl}{0878090@hr.nl} % Second author's email address
}
\date{\today} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
  \begin{abstract}
    \noindent
    Met de komst van het internet, big data en de toenemende capaciteit van
    computers is er vernieuwde interesse in de functionele programmeertalen. Dit
    rapport bekijkt samen met de lezer de voor en nadelen bij de stelling
    \textit{``Het functionele paradigma is de toekomst.''} Dit gebeurt op basis
    van een literatuuronderzoek naar de relaties en verschillen van de heersende
    programmeerparadigma's. Het onderzoek beperkt zich tot het imperatieve en
    functionele paradigma. Om het functionele paradigma en zijn plaats binnen de
    informatica beter te kunnen begrijpen is er binnen dit onderzoek van een
    minimale kennisgeving van de heersende programmeerparadigma's uitgegaan. Ook
    is kennis van programmeren wenselijk, maar kan het onderzoek ook prima zonder
    deze kennis worden gevolgd.
  \end{abstract}
}

%------------------------------------------------------------------------------

\begin{document}
\nocite{*}

% Print the title
\maketitle

%------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%------------------------------------------------------------------------------

\section{Inleiding}
\lettrine[nindent=0em,lines=3]{V}oor het maken van programma's wordt er gebruik
gemaakt van programmeertalen. Door het gebruik van een programmeertaal is het
mogelijk voor een programmeur om een computer te voorzien van instructies en zo
de gigantische rekenkracht van het apparaat te benutten. Er zijn door de jaren
heen veel programmeertalen ontwikkelt. Sommige revolutionair en vernieuwend,
andere een uitbreiding op reeds bestaande talen. Veel van deze programmeertalen
delen dezelfde kenmerken en kunnen worden geclassificeerd onder een
paradigma.

Het is daarom van essentieel belang dat een keuze voor een paradigma
afhankelijk is van een correcte probleem- of doelstelling. Zo wordt er vanuit
de academische en wetenschappelijke hoek al jaren aangezet tot een transitie
naar het functionele paradigma, maar worden functionele programmeertalen, zoals
Haskell en Lisp vaak als een onconventionele, onwerkbare vorm van software
ontwikkeling gezien. Echter wordt er momenteel met de komst van het internet en
big data een nieuwe effici\"ente manier van dataverwerking toegepast die
veelal gebruik maakt van parallel, gelijktijdig en gedistribueerd programmeren.

Deze oplossingen schikken zich vaak voor een functionele aanpak van het
probleem, maar de achterliggende infrastructuur is vaak imperatief en
objectgeori\"enteerd waardoor een combinatie veelal uitgesloten is, maar wel
wenselijk.

%------------------------------------------------------------------------------

\section{Middenstuk}

In dit middenstuk zal er een korte uitleg worden gegeven wat de imperatieve en
functionele programmeerparadigma's inhouden. Opvolgend zal er worden gekeken
naar twee kanten van deze stelling, namelijk de voor en tegenargumentatie.

Om de plaats van het functionele programmeerparadigma beter te kunnen
begrijpen, zal er eerst gekeken moeten worden naar de andere dominante
paradigma's. De paradigma's die kort besproken zullen worden zijn: het
imperatieve en functionele programmeerparadigma.

%------------------------------------------------------------------------------

\subsection{Imperatief programmeren}
Imperatief programmeren houdt in dat een programma een structuur beschrijft
volgens het Turingmodel. Dit programma wordt door de computer ingelezen in het
geheugen om het in kleine delen sequentieel uit te voeren. De tussentijdse
berekeningen worden in een imperatieve taal als data opgeslagen in het
geheugen. Deze data kan vervolgens worden opgehaald en gemuteerd door elk
volgende instructie die toegang heeft tot deze data, totdat er een antwoord
wordt gepresenteerd. Imperatieve programmeertalen zijn door deze eigenschap om
de huidige staat van een programma aan te passen zeer geschikt voor het
programmeren van computer hardware. Dit is de reden dat de imperatieve stijl
van programmeren hedendaags de gangbare manier van programmeren is.

\subsection{Functioneel programmeren}
Functioneel programmeren is een paradigma dat niet nieuw is, maar al sinds de
jaren 40 bestaat. Het is een paradigma wat is ontstaan uit het lambda
calculus\cite{pro1}, wat Turingvolledig is. Kenmerkend voor functioneel programmeren is het
programmeren met functies, het vermijden van globale staat, de niet
muteerbare data structuren en een executie model waarin de evaluatie volgorde
niet uitmaakt.

%------------------------------------------------------------------------------

\section{Algemene voordelen functioneel programmeren}

Nu er kort uitleg is gegeven over imperatieve en functionele talen kunnen we
kijken naar de verschillen tussen beide paradigma's. Het meest voorkomende
paradigma is het imperatief programmeren. Het is echter pas sinds kort dat
er hernieuwde interesse is ontstaan in het functionele paradigma vanwege de
expressiviteit en het vermogen van deze talen om foutloos gelijktijdig
programma's uit te voeren. Deze eigenschappen maken functionele talen geschikt
voor het verwerken van de grote hoeveelheden data in een gedistribueerde
omgeving. Sinds de komst van het internet en big data zijn de traditionele
manieren van dataverwerking niet meer toereikend genoeg. De oplossing: het
verdelen van de data over verschillende multi-core processoren,
zodat de verwerking van deze data sneller verloopt; dit heet in de informatica
gedistribueerd programmeren.

Gedistribueerd programmeren is een complex onderwerp in de informatica en niet
zonder enige risico's. Doordat er meerdere multi-core processoren betrokken
zijn bij de executie van het programma, wat tevens gelijktijdig kan gebeuren,
is het cruciaal dat de evaluatie volgorde van het programma klopt. Echter is
het moeilijk om deze evaluatie volgorde te waarborgen aangezien de aangesproken
processoren niet dezelfde throughput hebben. Hierdoor zijn uitspraken over
ruimte en tijd complexiteit moeilijk voor een programmeur. In veel imperatieve
programmeertalen zijn locks of mutexes genoemd, ge\"introduceerd met als
doel het correct afhandelen van deze executievolgorde. Echter zijn de
ge\"introduceerde oplossingen niet zonder bijwerkingen. Bijwerkingen van deze
oplossingen kunnen er voor zorgen dat het programma beland in een deadlock of
dat het leidt tot onverwachtse resultaten door data races\cite{pro13}. Deze
bijwerkingen kunnen worden verklaard doordat data in imperatieve
programmeertalen muteerbaar is en deze talen inherent sequentieel zijn.

Functionele programmeertalen hebben echter geen van de bovengenoemde problemen.
Deze talen niet afhankelijk van de evaluatie volgorde en zijn er geen locks of
mutexes, wat ze uitsluit voor deadlocks. Dit maakt het mogelijk om
verschillende stukken van een expressie parallel te evalueren, wat een pre is
voor gedistribueerd programmeren. Tevens is de data in de functionele
programmeertalen niet muteerbaar, wat inhoudt dat er geen bijwerkingen zijn
en data races niet tot nauwelijks voor kunnen komen in deze talen.

Functionele programmeertalen zijn ook erg schaalbaar. Door het gebruik van
hogere graads functies kunnen functies gedeeltelijk worden toegepast. Dit
maakt het mogelijk om nieuwe functies van oude functies af te leiden, wat
ervoor zorgt dat de functies onafhankelijk zijn en zeer schaalbaar. Door de
schaalbaarheid van deze talen zijn de algoritmes geschreven in een functionele
taal vaak korter en leesbaarder dan in een imperatieve programmeertaal. Door
vervolgens een collectie van gerelateerde functies te combineren ontstaan er
zogeheten modules, welk herbruikbaar en gemakkelijk te beheren zijn.
Functionele talen zijn dus geschikt wanneer er een vaste verzameling
\textit{dingen} is en naarmate de code evalueert, er voornamelijk nieuwe
bewerkingen toe worden gevoegd aan deze bestaande dingen. Wat deze talen zeer
geschikt maakt voor het manipuleren van symbolische data in boom formaat.
Dit in tegenstelling tot imperatieve talen, welke zich meer schikken naar een
vaste set bewerkingen op \textit{dingen} en naarmate de code evalueert, er
vooral nieuwe dingen worden toegevoegd.

%------------------------------------------------------------------------------

\section{Algemene nadelen functioneel programmeren}
Dat functioneel programmeren tegenwoordig voor steeds meer situaties en
problemen een gangbare oplossing is, zagen we in de vorige sectie. Echter zijn
er ook situaties en problemen die zich niet schikken voor een functionele
oplossing. Embedded systemen is \'e\'en van deze gebieden waarin functionele
programmeertalen niet geschikt zijn voor het schrijven van programma's
(ook wel firmware genoemd).

Embedded systemen zijn gemaakt voor het uitvoeren van een specifieke taak
en beschikken vaak over weinig intern geheugen. Ook kunnen deze systemen een
andere processor hebben die kan verschillen met de processor die normaliter in
een algemene (thuis)computer zit. Door het beperkte interne geheugen en de vele
verschillende processoren, zijn functionele programmeertalen niet geschikt
voor het schrijven van de firmware voor deze systemen. Functionele
programmeertalen gebruiken namelijk aanzienlijk meer geheugen dan hun
imperatieve tegenhangers. Data is in deze talen niet muteerbaar en voor elke
berekening moet er een nieuw stuk geheugen worden aangesproken.

Doordat er weinig geheugen beschikbaar is in deze systemen en er veel
verschillende processorarchitecturen bestaan, is het voor veel programmeurs
noodzakelijk om direct het geheugen te kunnen controleren. Echter zijn veel
functionele programmeertalen afhankelijk van compiler optimalisatie, waar de
compiler vaak geleverd wordt met een garbage collector. Het gebruik van een
garbage collector is voor embedded systemen een enorme beperking aangezien de
programmeur het onderliggende geheugen niet kan controleren. Door deze
beperking zijn de meeste functionele programmeertalen aanzienlijk langzamer ten
opzichte van imperatieve programmeertalen en kan het verlies in snelheid worden
teruggeleid en verklaard door de focus op abstractie van de functionele talen.
Door de focus op abstractie duurt een translatie van een programma naar machine
code in een functionele programmeertaal door de compiler vaak langer dan
dezelfde translatie gedaan in \'e\'en van de imperatieve talen.

Een andere veel voorkomend probleem is dat veel van de huidige systemen die
momenteel in de omloop zijn, geschreven zijn in een imperatieve taal. Veel van
deze systemen zijn al jaren in ontwikkeling en een complete herschrijving van
zulke systemen is vaak erg tijdrovend en niet winstgevend. Door vervolgens
nieuwe functionele code te koppelen met de huidige imperatieve systemen,
ontstaan er koppelingsproblemen.

\section{Conclusie}
\blindtext % Dummy text

%------------------------------------------------------------------------------
%	REFERENCE LIST
%------------------------------------------------------------------------------

\bibliographystyle{IEEEtran}
\bibliography{main}

\clearpage
\onecolumn

%------------------------------------------------------------------------------
%	APPENDIX
%------------------------------------------------------------------------------

\begin{appendices}

  \AppendixSection{Terminologie}

  \AppendixItem{Big Data}{
    Data sets die zo enorm en complex zijn dat traditionele
    dataverwerkingssoftware niet langer toereikend zijn.
  }

  \AppendixItem{Lambda calculus}{
    Het originele model achter de computer, bedacht door de wiskundige Alan
    Turing in 1936.
  }

  \AppendixItem{Multi-core processoren}{
    Multi-core processoren, bestaan uit verschillende processoren en gedeeld
    geheugen, zie figuur~\ref{fig:./fig/mutlicore.png}.
    \fig{0.6}{./fig/mutlicore.png}{Multicore}
  }

  \AppendixItem{Parallel proces}{
    De verschillende kernen zoals, te zien in
    figuur~\ref{fig:./fig/mutlicore.png} kunnen ook parallel verschillende
    stukken van het programma uitvoeren,
    zoals te zien in figuur~\ref{fig:./fig/parallel_process.png}. Als
    verschillende kernen zinnig werk tegelijkertijd doen kan dit het gehele
    proces versnellen.
    \fig{0.6}{./fig/parallel_process.png}{Parallel proces}
  }

  \newpage

  \AppendixItem{Race conditie}{
    Twee processen P1 en  P2, kunnen beide schrijven naar de variabel
    $tmp$. De intentie van de programmeur is dat zowel proces P1 als P2
    $tmp$ van een waarde voorziet, deze vervolgens gelijk te gebruiken en een
    uiteindelijke waarde voor $y$ en $z$ te presenteren. De executie van
    algoritme~\ref{algo:algo1} levert de volgende waardes voor $y$ en $z$:
    \begin{gather*}
      y = 24, z = 2055
    \end{gather}

    Echter doordat de processen op verschillende snelheden kunnen draaien, doet
    zich een situatie voor, zoals te zien in algoritme~\ref{algo:algo2} waar de
    volgorde van executie niet wordt uitgevoerd zoals de programmeur had
    bedoeld. De executie van dit algoritme levert de volgende waardes voor $y$
    en $z$:
    \begin{gather*}
      y = 4096, z = 2055
    \end{gather}
    Zoals te zien is dit niet de juiste waarde voor $y$. Deze situatie wordt
    ook wel een race conditie genoemd in de informatica.

    \begin{multicols}{2}
      \begin{algorithm}[H]
        \caption{Programmeurs intentie}
        \label{algo:algo1}
        \begin{algorithmic}
          \Variables
          \State $tmp$
          \EndVariables
          \begin{multicols}{2}
            \Procedure{P1}{}
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \State $tmp = 12 $
            \State $y = 2 \times tmp$
            \EndProcedure
            \columnbreak
            \Procedure{P2}{}
            \State $tmp = 2048$
            \State $z = tmp + 7$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \EndProcedure
          \end{multicols}
        \end{algorithmic}
      \end{algorithm}
      \columnbreak
      \begin{algorithm}[H]
        \caption{Race conditie}
        \label{algo:algo2}
        \begin{algorithmic}
          \Variables
          \State $tmp$
          \EndVariables
          \begin{multicols}{2}
            \Procedure{P1}{}
            \State $tmp = 12 $
            \State $\mathbf{.}$
            \State $y = 2 \times tmp$
            \State $\mathbf{.}$
            \State $\mathbf{.}$
            \EndProcedure
            \columbreak
            \Procedure{P2}{}
            \State $\mathbf{.}$
            \State $tmp = 2048$
            \State $\mathbf{.}$
            \State $z = tmp + 7$
            \State $\mathbf{.}$
            \EndProcedure
          \end{multicols}
        \end{algorithmic}
      \end{algorithm}
    \end{multicols}
  }

  \AppendixItem{Throughput}{
    Maximale snelheid waarop \textit{iets} kan worden verwerkt.
  }


  \AppendixItem{Turingmodel}{
    Het originele model achter de computer, bedacht door de wiskundige Alan
    Turing in 1936.
  }

  \AppendixItem{Turingvolledig}{
    \textit{Iets} is turingvolledig, wanneer het een turing machine kan
    simuleren.
  }

\end{appendices}

%------------------------------------------------------------------------------

\end{document}
